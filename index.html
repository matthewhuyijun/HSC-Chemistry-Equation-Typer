<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
<meta charset="utf-8" />
<title>HSC Chemistry – Equation Typer (with Isotopes)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<script src="https://unpkg.com/lucide@latest"></script>
<style>
:root {
  color-scheme: light;
  --page-max-width: 2280px;
  --page-pad-x: 24px;
  --content-max: var(--page-max-width);
  --content-pad-x: var(--page-pad-x);
  --bg: #f8fafc;
  --card: #ffffff;
  --ink: #111827;
  --muted: #6b7280;
  --brand: #2563eb;
  --brand-ink: #ffffff;
  --border: #e2e8f0;
  --key-bg: rgba(255, 255, 255, 0.9);
  --copy-bg: #ffffff;
  --copy-border: rgba(15, 23, 42, 0.15);
  --copy-ink: #0f172a;
  --copy-hover-bg: var(--brand);
  --copy-hover-ink: var(--brand-ink);
  --copy-hover-border: rgba(37, 99, 235, 0.65);
  --color-header-bg: var(--brand);
  --color-header-text: var(--brand-ink);
  --color-surface: var(--card);
  --color-border: var(--border);
  --color-tab-active-bg: var(--brand);
  --color-tab-active-text: var(--brand-ink);
  --wallpaper-light: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='28' height='28' viewBox='0 0 28 28'><rect width='100%' height='100%' fill='none'/><circle cx='14' cy='14' r='0.75' fill='%23cbd5e1' opacity='0.55'/></svg>");
  --wallpaper-dark: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='28' height='28' viewBox='0 0 28 28'><rect width='100%' height='100%' fill='none'/><circle cx='14' cy='14' r='0.75' fill='%23334155' opacity='0.55'/></svg>");
  --wallpaper: var(--wallpaper-light);
  --scale: 1.1;
}
[data-theme="dark"] {
  color-scheme: dark;
  --bg: #0f172a;
  --card: #1e293b;
  --ink: #e2e8f0;
  --muted: #94a3b8;
  --brand: #1d4ed8;
  --brand-ink: #f8fafc;
  --border: #334155;
  --key-bg: rgba(30, 41, 59, 0.9);
  --copy-bg: rgba(15, 23, 42, 0.85);
  --copy-border: rgba(148, 163, 184, 0.45);
  --copy-ink: #f8fafc;
  --copy-hover-bg: var(--brand);
  --copy-hover-ink: var(--brand-ink);
  --copy-hover-border: rgba(37, 99, 235, 0.65);
  --color-header-bg: var(--brand);
  --color-header-text: var(--brand-ink);
  --color-surface: var(--card);
  --color-border: var(--border);
  --color-tab-active-bg: var(--brand);
  --color-tab-active-text: var(--brand-ink);
  --wallpaper: var(--wallpaper-dark);
}
* {
  box-sizing: border-box;
}
html, body { overflow: hidden; overscroll-behavior: none; touch-action: pan-y; }
body {
  font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Ubuntu, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif;
  margin: 0;
  background: var(--bg);
  color: var(--ink);
  transition: background 0.3s ease, color 0.3s ease;
  font-size: calc(16px * var(--scale));
}
header {
  padding: calc(12px * var(--scale)) 0;
  background: linear-gradient(135deg, #2563eb, #3b82f6 60%, #6366f1);
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
}
.header-inner {
  width: 100%;
  max-width: var(--page-max-width);
  margin: 0 auto;
  padding: 0 var(--page-pad-x);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: calc(12px * var(--scale));
}
header h1 {
  font-size: calc(18px * var(--scale));
  margin: 0;
  font-weight: 700;
  color: #ffffff;
}
header .header-left {
  display: flex;
  align-items: center;
  gap: calc(12px * var(--scale));
  flex-wrap: wrap;
}
.header-actions {
  display: flex;
  gap: calc(12px * var(--scale));
  flex-wrap: wrap;
}
.header-controls {
  display: flex;
  align-items: center;
  gap: calc(16px * var(--scale));
}
#status {
  font-size: calc(14px * var(--scale));
  font-weight: 600;
  opacity: 0.95;
  color: var(--brand-ink);
}
.visually-hidden {
  position: absolute !important;
  height: 1px;
  width: 1px;
  overflow: hidden;
  clip: rect(1px, 1px, 1px, 1px);
  white-space: nowrap;
  border: 0;
  padding: 0;
  margin: -1px;
}
.theme-switch{
  display: flex;
  align-items: center;
  gap: 4px;
}
.theme-opt{
  appearance: none;
  min-height: 36px;
  min-width: 36px;
  padding: 6px;
  border-radius: 8px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  background: transparent;
  border: none;
  color: rgba(255, 255, 255, 0.85);
  cursor: pointer;
  transition: all 0.2s ease;
}
.theme-opt.is-active{
  background: rgba(255, 255, 255, 0.2);
  color: rgba(255, 255, 255, 1);
}
.theme-opt:hover{ 
  background: rgba(255, 255, 255, 0.15);
  color: rgba(255, 255, 255, 1);
}
.theme-opt:active {
  background: rgba(255, 255, 255, 0.25);
}
.theme-opt svg {
  width: 18px;
  height: 18px;
  display: block;
  stroke: currentColor;
  stroke-width: 2;
  fill: none;
  transition: transform 0.2s ease;
}
.theme-opt:hover svg {
  transform: scale(1.1);
}
main {
  width: 100%;
  max-width: var(--content-max);
  margin-left: auto;
  margin-right: auto;
  margin-top: calc(18px * var(--scale));
  margin-bottom: calc(18px * var(--scale));
  padding-left: var(--content-pad-x);
  padding-right: var(--content-pad-x);
  padding-bottom: calc(24px * var(--scale));
  display: grid;
  gap: calc(12px * var(--scale));
}
.panel,
.card {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: calc(12px * var(--scale));
  overflow: hidden;
  box-shadow: 0 1px 1px rgba(15, 23, 42, 0.06);
}
.panel .head {
  padding: calc(10px * var(--scale)) calc(12px * var(--scale));
  border-bottom: 1px solid var(--border);
  font-weight: 600;
  display: flex;
  justify-content: center;
  align-items: center;
  color: var(--ink);
  text-align: center;
}
.panel .body,
.card .body {
  padding: calc(12px * var(--scale));
}
math-field,
textarea {
  font-size: calc(18px * var(--scale));
  padding: calc(10px * var(--scale));
  border: 1px solid var(--border);
  border-radius: calc(10px * var(--scale));
  background: var(--card);
  color: var(--ink);
  width: 100%;
  transition: border-color 0.2s ease, background 0.2s ease;
}
math-field {
  min-height: calc(52px * var(--scale));
}
textarea {
  min-height: calc(52px * var(--scale));
  resize: none;
}
#ta {
  min-height: calc(52px * var(--scale));
}
.preview-card .body {
  padding: 0;
}
#preview {
  min-height: calc(52px * var(--scale));
  padding: calc(16px * var(--scale));
}
.row {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: calc(10px * var(--scale));
  align-items: center;
}
.btn {
  padding: calc(4px * var(--scale)) calc(8px * var(--scale));
  border: 1px solid var(--border);
  border-radius: calc(6px * var(--scale));
  background: var(--card);
  cursor: pointer;
  font-size: calc(12px * var(--scale));
  color: var(--ink);
}
.btn:active {
  transform: translateY(calc(1px * var(--scale)));
}
.btn:focus-visible {
  outline: calc(2px * var(--scale)) solid var(--brand);
  outline-offset: calc(2px * var(--scale));
}
.btn:hover,
.btn:focus-visible {
  background: var(--copy-hover-bg);
  border-color: var(--copy-hover-border);
  color: var(--copy-hover-ink);
}
.copyBtn,
.header-copy {
  appearance: none;
  align-items: center;
  justify-content: center;
  display: inline-flex;
  gap: calc(6px * var(--scale));
  padding: calc(8px * var(--scale)) calc(18px * var(--scale));
  border-radius: calc(999px * var(--scale));
  border: 1px solid var(--copy-border);
  background: var(--copy-bg);
  color: var(--copy-ink);
  font-size: 1em;
  font-weight: 600;
  cursor: pointer;
  letter-spacing: -0.01em;
  box-shadow: 0 calc(6px * var(--scale)) calc(18px * var(--scale)) rgba(15, 23, 42, 0.25);
  transition: background 0.18s ease, color 0.18s ease, box-shadow 0.18s ease, transform 0.12s ease, border-color 0.18s ease;
}
.copyBtn {
  font-size: calc(12px * var(--scale));
}
.header-copy {
  appearance: none;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 11px 24px;
  border-radius: 999px;
  background-color: #ffffff;
  border: none;
  color: #1e293b;
  font-weight: 700;
  font-size: 15px;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15), 0 1px 3px rgba(0, 0, 0, 0.1);
}
.copyBtn:hover,
.copyBtn:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--copy-bg));
  border-color: var(--color-tab-active-bg);
  box-shadow: 0 6px 16px rgba(37, 99, 235, 0.25);
  transform: translateY(-1px);
}
.header-copy:hover {
  transform: translateY(-1px);
}
.header-copy:focus-visible {
  background-color: #f8fafc;
  outline: 2px solid rgba(255, 255, 255, 0.5);
  outline-offset: 2px;
  transform: translateY(-1px);
}

[data-theme="dark"] .header-copy:focus-visible {
  background-color: var(--card) !important;
  outline: 2px solid rgba(255, 255, 255, 0.3);
}
.copyBtn:focus-visible {
  outline: calc(2px * var(--scale)) solid rgba(37, 99, 235, 0.6);
  outline-offset: calc(2px * var(--scale));
}
.copyBtn:active {
  box-shadow: 0 calc(2px * var(--scale)) calc(8px * var(--scale)) rgba(15, 23, 42, 0.25);
}
.header-copy:active {
  background-color: #e2e8f0;
  transform: translateY(0);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

[data-theme="dark"] .header-copy:active {
  background-color: var(--card) !important;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

/* Dark mode header buttons */
[data-theme="dark"] .header-copy {
  background-color: var(--card) !important;
  border: 1px solid var(--border) !important;
  color: var(--ink) !important;
}

[data-theme="dark"] .header-copy:hover {
  background: #1d4ed8 !important;
  border-color: #1d4ed8 !important;
  box-shadow: 0 6px 16px rgba(37, 99, 235, 0.25) !important;
  transform: translateY(-1px) !important;
}
#keyboard {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(0, 1fr));
  gap: calc(8px * var(--scale));
  width: 100%;
}
.key {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: calc(48px * var(--scale));
  padding: calc(6px * var(--scale)) calc(12px * var(--scale));
  background: var(--key-surface);
  border: 1px solid var(--key-border);
  border-radius: calc(6px * var(--scale));
  cursor: pointer;
  font-size: calc(13px * var(--scale));
  width: 100%;
  color: var(--ink);
  transition: background 0.18s ease, color 0.18s ease, border-color 0.18s ease, box-shadow 0.18s ease, transform 0.12s ease;
}
.key mjx-container {
  font-size: calc(16px * var(--scale));
  max-width: 100%;
}
.key:hover,
.key:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--key-surface));
  border-color: var(--color-tab-active-bg);
  transform: translateY(calc(-1px * var(--scale)));
}
.key:active {
  transform: translateY(calc(1px * var(--scale)));
}
.hint { font-size: calc(12px * var(--scale)); color: var(--muted); margin-top: calc(4px * var(--scale)); }
.editor {
  display: grid;
  gap: calc(6px * var(--scale));
}
.editor label {
  display: flex;
  align-items: center;
  gap: calc(8px * var(--scale));
  font-size: calc(13px * var(--scale));
  color: var(--muted);
}
.editor label strong {
  font-weight: 600;
  color: var(--ink);
}
.editor .copyBtn {
  margin-left: auto;
}
.stack {
  display: grid;
  gap: calc(16px * var(--scale));
}
math-field::part(virtual-keyboard-toggle),
math-field::part(menu-toggle),
math-field::part(toolbar) {
  display: none !important;
}

/* === Pretty-up pack (drop-in overrides) === */

/* Font & smoother text rendering */
html, body {
  font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Subtle gradient background that adapts to theme */
:root {
  --bg-grad-1: radial-gradient(1200px 600px at 10% -10%, rgba(37, 99, 235, 0.10), transparent 60%),
               radial-gradient(900px 500px at 110% 10%, rgba(99, 102, 241, 0.10), transparent 60%);
}
[data-theme="dark"] {
  --bg-grad-1: radial-gradient(1200px 600px at 10% -10%, rgba(37, 99, 235, 0.18), transparent 60%),
               radial-gradient(900px 500px at 110% 10%, rgba(99, 102, 241, 0.18), transparent 60%);
}
body {
  background-image: var(--bg-grad-1), var(--wallpaper);
  background-size: auto, 28px 28px;
  background-attachment: fixed, fixed;
  background-position: center, center;
  background-repeat: no-repeat, repeat;
}

/* Header glow-up */
header {
  background: linear-gradient(135deg, var(--color-header-bg), #3b82f6 55%, #6366f1);
  box-shadow: 0 8px 20px rgba(2, 6, 23, 0.28);
}
header h1 {
  letter-spacing: -0.01em;
  font-size: 20px;
  line-height: 1.2;
  position: relative;
}
header h1::after {
  content: "";
  position: absolute;
  left: 0; bottom: -6px;
  width: 100px; height: 3px;
  border-radius: 999px;
  background: linear-gradient(90deg, #ffffffaa, #c7d2fe 60%, transparent);
  filter: blur(.3px);
}

/* Panels & cards with glassy feel */
.panel,
.card {
  border-radius: 18px;
  backdrop-filter: saturate(1.1) blur(6px);
  background: color-mix(in srgb, var(--color-surface) 86%, transparent);
  border: 1px solid color-mix(in srgb, var(--color-border) 70%, transparent);
  transition: transform .15s ease, box-shadow .2s ease, background .2s ease, border-color .2s ease;
}
.panel:hover,
.card:hover {
  transform: none;
  box-shadow: 0 16px 30px rgba(8, 15, 35, 0.18);
  background: color-mix(in srgb, var(--color-surface) 92%, transparent);
}

/* Inputs: clearer focus ring */
math-field, textarea {
  border-radius: 10px;
  box-shadow: 0 1px 0 rgba(2, 6, 23, 0.04);
}
math-field:focus-within, textarea:focus {
  outline: 2px solid color-mix(in srgb, var(--color-tab-active-bg) 60%, white);
  outline-offset: 2px;
  border-color: var(--color-tab-active-bg);
}

/* Preview surface */
#preview {
  border-radius: 14px;
  background: color-mix(in srgb, var(--color-surface) 92%, transparent);
  border: 1px solid color-mix(in srgb, var(--color-border) 70%, transparent);
}

/* Copy buttons */
.copyBtn, .header-copy {
  letter-spacing: 0;
  border-radius: 12px;
  padding: 9px 18px;
  box-shadow: 0 10px 24px rgba(2, 6, 23, 0.2);
}

/* Keyboard keys */
.key {
  border-radius: 14px;
  box-shadow: 0 10px 22px rgba(2, 6, 23, 0.12);
  transition: transform .12s ease, box-shadow .12s ease, background-color .2s ease, border-color .2s ease;
}


/* === Copy toast styles === */
#toast {
  position: fixed;
  left: 50%;
  bottom: 40px;
  transform: translateX(-50%) translateY(40px);
  background: rgba(34,197,94,0.95); /* green success */
  color: #fff;
  padding: 10px 18px;
  border-radius: 999px;
  font-size: 14px;
  font-weight: 700;
  letter-spacing: 0.01em;
  box-shadow: 0 12px 28px rgba(2,6,23,0.25);
  opacity: 0;
  pointer-events: none;
  transition: opacity .25s ease, transform .25s ease;
  z-index: 9999;
}
#toast.show {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}

/* Responsive styles for smaller screens */
@media (max-width: 640px) {
  :root {
    --page-pad-x: 16px;
    --content-pad-x: var(--page-pad-x);
  }
}

/* === EXACT Ext2 key glow – copied verbatim === */
/* Tokens used by Ext2 keys */
:root {
  --key-surface: rgba(255, 255, 255, 0.96);
  --key-border: rgba(148, 163, 184, 0.38);
}
[data-theme="dark"] {
  --key-surface: rgba(30, 44, 76, 0.92);
  --key-border: rgba(84, 105, 150, 0.55);
}

/* Base key look from Ext2 */
.key {
  border-radius: 14px;
  border: 1px solid var(--key-border);
  background: var(--key-surface);
  box-shadow: 0 10px 22px rgba(2, 6, 23, 0.12);
  transition:
    transform .12s ease,
    box-shadow .12s ease,
    background-color .2s ease,
    border-color .2s ease;
}

/* Ext2 hover (no ring/filter, fixed -1px lift, specific shadow) */
.key:hover,
.key:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--key-surface));
  border-color: var(--color-tab-active-bg);
  transform: translateY(-1px);
  box-shadow: 0 12px 22px rgba(15, 23, 42, 0.18);
  filter: none;
  outline: none;
}

/* === TABS SECTION === */
.tab {
  padding: 10px 16px;
  border: 1px solid var(--color-border);
  border-radius: 12px;
  cursor: pointer;
  background: var(--color-tab-bg);
  color: var(--color-tab-text);
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  font-size: 12px;
  font-weight: 600;
  transition: background .2s ease, border-color .2s ease, box-shadow .2s ease, transform .15s ease;
  flex: 1;
  min-width: 0;
  text-align: center;
  width: 100%;
  max-width: none;
}

/* === EXT2-style hover glow for Chemistry tabs === */
.tab:hover,
.tab:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--color-tab-bg));
  border-color: var(--color-tab-active-bg);
  transform: translateY(-1px);
  box-shadow: 0 12px 22px rgba(15, 23, 42, 0.18);
  filter: drop-shadow(0 0 10px rgba(37,99,235,0.35));
}

/* === Ext2-identical header button glow (light & dark) === */
.header-copy {
  border: 1px solid var(--copy-border);
  background: var(--copy-bg);
  color: var(--copy-ink);
  box-shadow: 0 6px 18px rgba(15, 23, 42, 0.25);
  transition: background .18s ease, color .18s ease, box-shadow .18s ease, transform .12s ease, border-color .18s ease;
}
.header-copy:hover,
.header-copy:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--copy-bg));
  border-color: var(--color-tab-active-bg);
  box-shadow: 0 6px 16px rgba(37, 99, 235, 0.25);
  transform: translateY(-1px);
  outline: 2px solid rgba(37, 99, 235, 0.6);
  outline-offset: 2px;
}
.header-copy:active { box-shadow: 0 2px 8px rgba(15, 23, 42, 0.25); transform: translateY(0); }

/* Dark mode: apply the exact same recipe (tokens swap under dark) */
[data-theme="dark"] .header-copy,
[data-theme="dark"] .header-copy:hover,
[data-theme="dark"] .header-copy:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--copy-bg));
  /* ensure border/ink come from the same token set Ext2 uses */
  border-color: var(--color-tab-active-bg);
  color: var(--copy-ink);
  box-shadow: 0 6px 16px rgba(37, 99, 235, 0.25);
}

/* === EXT2-EXACT GLOW for keys + header buttons (light & dark) === */
/* Key base (from Ext2) */
.key {
  border-radius: 14px;
  border: 1px solid var(--key-border);
  background: var(--key-surface);
  box-shadow: 0 10px 22px rgba(2, 6, 23, 0.12);
  transition: transform .12s ease, box-shadow .12s ease, background-color .2s ease, border-color .2s ease;
}
/* Key hover: no neon ring, exact tint + lift + shadow */
.key:hover,
.key:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--key-surface));
  border-color: var(--color-tab-active-bg);
  transform: translateY(-1px);
  box-shadow: 0 12px 22px rgba(15, 23, 42, 0.18);
  outline: none;
  filter: none;
}
/* Kill any previous outlines/rings that caused the blue "neon" look */
.key:focus { outline: none; }

/* Header buttons base (match Ext2) */
.header-copy {
  border: 1px solid var(--copy-border);
  background: var(--copy-bg);
  color: var(--copy-ink);
  box-shadow: 0 6px 18px rgba(15, 23, 42, 0.25);
  transition: background .18s ease, color .18s ease, box-shadow .18s ease, transform .12s ease, border-color .18s ease;
}
/* Header buttons hover/focus: exact Ext2 recipe */
.header-copy:hover,
.header-copy:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--copy-bg));
  border-color: var(--color-tab-active-bg);
  box-shadow: 0 6px 16px rgba(37, 99, 235, 0.25);
  transform: translateY(-1px);
  outline: 2px solid rgba(37, 99, 235, 0.6);
  outline-offset: 2px;
  color: var(--color-tab-active-text);
}
.header-copy:active { box-shadow: 0 2px 8px rgba(15, 23, 42, 0.25); transform: translateY(0); }
.header-copy svg { stroke: currentColor; }

/* Dark mode: remove Chem overrides that broke Ext2 glow */
[data-theme="dark"] .header-copy,
[data-theme="dark"] .header-copy:hover,
[data-theme="dark"] .header-copy:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--copy-bg));
  border-color: var(--color-tab-active-bg);
  color: var(--color-tab-active-text);
  box-shadow: 0 6px 16px rgba(37, 99, 235, 0.25);
}

/* === EXT2-identical header buttons (light & dark) === */
.header-copy {
  border: 1px solid var(--copy-border) !important;
  background: var(--copy-bg) !important;
  color: var(--copy-ink) !important;
  box-shadow: 0 6px 18px rgba(15, 23, 42, 0.25) !important;
  transition: background .18s ease, color .18s ease,
              box-shadow .18s ease, transform .12s ease,
              border-color .18s ease !important;
}

.header-copy:hover,
.header-copy:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--copy-bg)) !important;
  border-color: var(--color-tab-active-bg) !important;
  box-shadow: 0 6px 16px rgba(37, 99, 235, 0.25) !important;
  transform: translateY(-1px) !important;
  outline: 2px solid rgba(37, 99, 235, 0.6) !important;
  outline-offset: 2px !important;
}

.header-copy:active {
  box-shadow: 0 2px 8px rgba(15, 23, 42, 0.25) !important;
  transform: translateY(0) !important;
}

/* ensure icons follow text color like Ext2 */
.header-copy svg { stroke: currentColor; }

/* === ChemistryTyper header buttons with E2-style dark glow === */
.header-actions .header-copy {
  border: 1px solid var(--copy-border);
  background: var(--copy-bg);
  color: var(--copy-ink);
  border-radius: 999px;
  box-shadow: 0 8px 20px rgba(2, 6, 23, 0.15);
  transition:
    background 0.18s ease,
    border-color 0.18s ease,
    box-shadow 0.18s ease,
    transform 0.12s ease,
    color 0.18s ease;
}

/* --- Hover / Focus: exact E2 blue highlight --- */
.header-actions .header-copy:hover,
.header-actions .header-copy:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--copy-bg));
  border-color: var(--color-tab-active-bg);
  transform: translateY(-1px);
  box-shadow:
    0 8px 20px rgba(37, 99, 235, 0.25),
    0 0 30px rgba(37, 99, 235, 0.3);
  outline: none;
  color: var(--copy-ink);
}

/* --- Active press --- */
.header-actions .header-copy:active {
  transform: translateY(0);
  box-shadow: 0 4px 10px rgba(37, 99, 235, 0.2);
}

/* --- Dark mode --- */
[data-theme="dark"] .header-actions .header-copy {
  background: var(--copy-bg);
  border: 1px solid var(--copy-border);
  color: var(--copy-ink);
}

[data-theme="dark"] .header-actions .header-copy:hover,
[data-theme="dark"] .header-actions .header-copy:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--copy-bg));
  border-color: var(--color-tab-active-bg);
  transform: translateY(-1px);
  box-shadow:
    0 8px 20px rgba(37, 99, 235, 0.35),
    0 0 40px rgba(37, 99, 235, 0.45);
  outline: none;
  color: var(--copy-ink);
}

/* === Chem header buttons: EXACT Ext2 glow === */
header .header-actions .header-copy{
  border: 1px solid var(--copy-border) !important;
  background: var(--copy-bg) !important;
  color: var(--copy-ink) !important;
  box-shadow: 0 6px 18px rgba(15,23,42,.25) !important;
  transition: background .18s ease, color .18s ease,
              box-shadow .18s ease, transform .12s ease,
              border-color .18s ease !important;
}

/* Hover/focus = Ext2 tint + lift (no neon ring) */
header .header-actions .header-copy:hover,
header .header-actions .header-copy:focus-visible{
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--copy-bg)) !important;
  border-color: var(--color-tab-active-bg) !important;
  transform: translateY(-1px) !important;
  box-shadow: 0 12px 22px rgba(15,23,42,.18) !important; /* same depth as Ext2 keys */
  outline: none !important;     /* kill white/blue ring */
  filter: none !important;
}

/* Active press */
header .header-actions .header-copy:active{
  transform: translateY(0) !important;
  box-shadow: 0 2px 8px rgba(15,23,42,.25) !important;
}

/* Icons track text color */
header .header-actions .header-copy svg{ stroke: currentColor !important; }

</style>
<script>
  window.MathJax = {
    tex: { inlineMath: [['$', '$'], ['$$', '$$']], macros: { placeholder: '\\square' } },
    svg: { fontCache: 'global' }
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" defer></script>
<link rel="stylesheet" href="https://unpkg.com/mathlive/dist/mathlive.core.css">
<link rel="stylesheet" href="https://unpkg.com/mathlive/dist/mathlive.css">
</head>
<body>
<header>
  <div class="header-inner">
    <div class="header-left">
      <div class="header-actions">
        <button type="button" class="header-copy" id="headerCopyLatex">
          <i data-lucide="copy"></i> Copy LaTeX
        </button>
        <button type="button" class="header-copy" id="headerCopyWord">
          <i data-lucide="file-text"></i> Copy Word Equation
        </button>
      </div>
    </div>
    <div class="header-controls">
      <div class="theme-switch" role="group" aria-label="Theme">
        <button class="theme-opt" data-theme="light" title="Light" aria-label="Switch to light theme">
          <i data-lucide="sun"></i>
        </button>
        <button class="theme-opt" data-theme="dark" title="Dark" aria-label="Switch to dark theme">
          <i data-lucide="moon"></i>
        </button>
        <button class="theme-opt is-active" data-theme="system" title="System" aria-label="Use system theme">
          <i data-lucide="monitor"></i>
        </button>
      </div>
    </div>
  </div>
</header>
<main>
  <div class="panel">
    <div class="body" id="keyboard"></div>
  </div>

  <div class="card preview-card">
    <div class="body">
      <div id="preview"></div>
    </div>
  </div>

  <div class="card">
    <div class="body stack">
      <div class="editor">
        <label><strong>Rendered Input (Editable)</strong></label>
        <math-field id="mf" smart-fence letter-shape-style="tex" virtual-keyboard-mode="off" remove-extraneous-parentheses="on" menu-items="[]" tabindex="0"></math-field>
      </div>
      <div class="editor">
        <label>
          <strong>Raw LaTeX Input</strong>
          <button id="copyLatex" class="copyBtn" type="button">Copy LaTeX</button>
        </label>
        <textarea id="ta"></textarea>
      </div>
      <div class="editor">
        <label>
          <strong>Word Equation</strong>
          <button id="copyWordBtn" class="copyBtn" type="button">Copy Word Equation</button>
        </label>
        <textarea id="wordOut" readonly></textarea>
      </div>
    </div>
  </div>
</main>

<script>
/* Theme toggle logic */
(function(){
  const html = document.documentElement;
  const opts = document.querySelectorAll('.theme-opt');
  const THEME_STORAGE_KEY = 'chem-typer-theme';
  const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');
  
  const apply = (mode)=>{
    opts.forEach(o=>o.classList.toggle('is-active', o.dataset.theme===mode));
    const resolved = mode === 'system' ? (prefersDarkScheme.matches ? 'dark' : 'light') : mode;
    html.setAttribute('data-theme', resolved); 
    html.style.colorScheme = resolved === 'dark' ? 'dark' : 'light';
    localStorage.setItem(THEME_STORAGE_KEY, mode); 
  };
  
  // Initialize - default to system
  const saved = localStorage.getItem(THEME_STORAGE_KEY) || 'system';
  apply(saved);
  
  // Bind click handlers
  opts.forEach(btn => btn.addEventListener('click', ()=> apply(btn.dataset.theme)));
  
  // Listen for system theme changes
  const handleSystemChange = () => {
    const current = localStorage.getItem(THEME_STORAGE_KEY) || 'system';
    if(current === 'system'){ apply('system'); }
  };
  if(typeof prefersDarkScheme.addEventListener === 'function'){
    prefersDarkScheme.addEventListener('change', handleSystemChange);
  } else if(typeof prefersDarkScheme.addListener === 'function'){
    prefersDarkScheme.addListener(handleSystemChange);
  }
})();

/* Initialize Lucide icons */
document.addEventListener('DOMContentLoaded', () => {
  lucide.createIcons();
});

const mathField = document.getElementById('mf');
const textArea = document.getElementById('ta');
const wordOutput = document.getElementById('wordOut');
const previewDiv = document.getElementById('preview');
const statusDiv = document.getElementById('status');

// Store raw LaTeX WITH \! for word equation generation
let rawLatex = '';

function showToast(message = 'Copied!') {
  const toast = document.getElementById('toast');
  if (!toast) return;
  toast.textContent = message;
  toast.classList.add('show');
  clearTimeout(showToast._timeout);
  showToast._timeout = setTimeout(() => toast.classList.remove('show'), 1600);
}

async function copyToClipboard(text, label = 'text') {
  let success = false;
  try {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      await navigator.clipboard.writeText(text);
      success = true;
    }
  } catch (err) {
    success = false;
  }

  if (!success) {
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.setAttribute('readonly', '');
    textarea.style.position = 'fixed';
    textarea.style.left = '-9999px';
    document.body.appendChild(textarea);
    textarea.select();
    try {
      success = document.execCommand('copy');
    } catch (err) {
      success = false;
    }
    document.body.removeChild(textarea);
  }

  if (statusDiv) {
    statusDiv.textContent = success ? `Copied ${label} ✓` : `Copy ${label} failed`;
  }
  showToast(success ? `Copied ${label} ✓` : 'Copy failed');
}

function typesetMath(){ 
  if(window.MathJax) {
    try {
      window.MathJax.typesetPromise([previewDiv]);
    } catch(e) {
      console.warn('MathJax typeset failed', e);
    }
  }
}

// ============================================================================
// AST-BASED LATEX → WORD UNICODEMATH CONVERTER
// ============================================================================

/**
 * Tokenizer: Splits LaTeX into structured tokens
 */
function tokenizeLatex(latex) {
    const tokens = [];
    let i = 0;
    const len = latex.length;
    
    while (i < len) {
        const ch = latex[i];
        
        // Skip whitespace
        if (/\s/.test(ch)) {
            i++;
            continue;
        }
        
        // LaTeX commands
        if (ch === '\\') {
            const start = i;
            i++; // skip '\'
            
            // Read command name
            while (i < len && /[a-zA-Z]/.test(latex[i])) {
                i++;
            }
            
            const cmd = latex.substring(start, i);
            
            // Handle command arguments
            let args = [];
            while (i < len && latex[i] === '{') {
                let depth = 0;
                const argStart = i;
                while (i < len) {
                    if (latex[i] === '{') depth++;
                    if (latex[i] === '}') {
                        depth--;
                        if (depth === 0) {
                            i++;
                            break;
                        }
                    }
                    i++;
                }
                args.push(latex.substring(argStart + 1, i - 1));
            }
            
            tokens.push({ type: 'command', value: cmd, args });
            continue;
        }
        
        // Braces
        if (ch === '{') {
            tokens.push({ type: 'lbrace' });
            i++;
            continue;
        }
        if (ch === '}') {
            tokens.push({ type: 'rbrace' });
            i++;
            continue;
        }
        
        // Subscript
        if (ch === '_') {
            tokens.push({ type: 'subscript' });
            i++;
            continue;
        }
        
        // Superscript
        if (ch === '^') {
            tokens.push({ type: 'superscript' });
            i++;
            continue;
        }
        
        // Plus sign
        if (ch === '+') {
            tokens.push({ type: 'plus' });
            i++;
            continue;
        }
        
        // Parentheses
        if (ch === '(') {
            tokens.push({ type: 'lparen' });
            i++;
            continue;
        }
        if (ch === ')') {
            tokens.push({ type: 'rparen' });
            i++;
            continue;
        }
        
        // Numbers
        if (/[0-9]/.test(ch)) {
            const start = i;
            while (i < len && /[0-9]/.test(latex[i])) {
                i++;
            }
            tokens.push({ type: 'number', value: latex.substring(start, i) });
            continue;
        }
        
        // Letters (elements, variables)
        if (/[A-Za-z]/.test(ch)) {
            const start = i;
            // Read capital letter optionally followed by lowercase
            i++;
            if (i < len && /[a-z]/.test(latex[i]) && /[A-Z]/.test(latex[start])) {
                i++;
            }
            tokens.push({ type: 'element', value: latex.substring(start, i) });
            continue;
        }
        
        // Greek letters and symbols (already converted)
        if (/[α-ωΑ-Ω]/.test(ch)) {
            tokens.push({ type: 'symbol', value: ch });
            i++;
            continue;
        }
        
        // Arrows and other special symbols
        if ('→←↔⇌⇒⇐±×·÷∞∂∇∫∑∏'.includes(ch)) {
            tokens.push({ type: 'symbol', value: ch });
            i++;
            continue;
        }
        
        // Other characters
        tokens.push({ type: 'char', value: ch });
        i++;
    }
    
    return tokens;
}

/**
 * AST Node types
 */
class ASTNode {
    constructor(type, value = null) {
        this.type = type;
        this.value = value;
        this.children = [];
        this.subscript = null;
        this.superscript = null;
    }
    
    addChild(node) {
        this.children.push(node);
        return this;
    }
}

/**
 * Parser: Converts tokens to AST
 */
function parseToAST(tokens) {
    let pos = 0;
    
    function peek() {
        return tokens[pos];
    }
    
    function consume() {
        return tokens[pos++];
    }
    
    function parseGroup() {
        const node = new ASTNode('group');
        
        while (pos < tokens.length) {
            const token = peek();
            
            if (!token || token.type === 'rbrace') {
                break;
            }
            
            node.addChild(parseExpression());
        }
        
        return node;
    }
    
    function parseExpression() {
        const token = consume();
        
        if (!token) return null;
        
        // Handle commands
        if (token.type === 'command') {
            return parseCommand(token);
        }
        
        // Handle grouped expressions
        if (token.type === 'lbrace') {
            const group = parseGroup();
            consume(); // consume '}'
            return group;
        }
        
        // Base node
        let node;
        if (token.type === 'element') {
            node = new ASTNode('element', token.value);
        } else if (token.type === 'number') {
            node = new ASTNode('number', token.value);
        } else if (token.type === 'symbol') {
            node = new ASTNode('symbol', token.value);
        } else if (token.type === 'char') {
            node = new ASTNode('char', token.value);
        } else if (token.type === 'plus') {
            node = new ASTNode('operator', '+');
        } else if (token.type === 'lparen') {
            node = new ASTNode('lparen', '(');
        } else if (token.type === 'rparen') {
            node = new ASTNode('rparen', ')');
        } else {
            node = new ASTNode('unknown', token.value);
        }
        
        // Check for subscripts/superscripts
        while (pos < tokens.length) {
            const next = peek();
            
            if (next && next.type === 'subscript') {
                consume(); // consume '_'
                node.subscript = parseScriptArg();
            } else if (next && next.type === 'superscript') {
                consume(); // consume '^'
                node.superscript = parseScriptArg();
            } else {
                break;
            }
        }
        
        return node;
    }
    
    function parseScriptArg() {
        const token = peek();
        
        if (token && token.type === 'lbrace') {
            consume(); // consume '{'
            const group = parseGroup();
            consume(); // consume '}'
            return group;
        }
        
        // Single token
        return parseExpression();
    }
    
    function parseCommand(token) {
        const node = new ASTNode('command', token.value);
        node.args = token.args || [];
        return node;
    }
    
    // Parse all expressions
    const root = new ASTNode('root');
    while (pos < tokens.length) {
        const expr = parseExpression();
        if (expr) {
            root.addChild(expr);
        }
    }
    
    return root;
}

/**
 * AST → UnicodeMath converter
 */
function astToUnicodeMath(node, context = {}) {
    if (!node) return '';
    
    let result = '';
    
    switch (node.type) {
        case 'root':
        case 'group':
            for (const child of node.children) {
                result += astToUnicodeMath(child, context);
            }
            break;
            
        case 'element':
            // Multi-letter elements need grouping
            if (node.value.length > 1) {
                result += `〖${node.value}〗`;
            } else {
                result += node.value;
            }
            
            // Add subscript
            if (node.subscript) {
                const subContent = astToUnicodeMath(node.subscript, context);
                result += `_${subContent} `; // Space after subscript
            }
            
            // Add superscript
            if (node.superscript) {
                const supContent = astToUnicodeMath(node.superscript, context);
                result += `^(${supContent}) `; // Space after superscript
            }
            break;
            
        case 'number':
            result += node.value;
            
            // Add subscript
            if (node.subscript) {
                const subContent = astToUnicodeMath(node.subscript, context);
                result += `_${subContent} `;
            }
            
            // Add superscript
            if (node.superscript) {
                const supContent = astToUnicodeMath(node.superscript, context);
                result += `^(${supContent}) `;
            }
            break;
            
        case 'symbol':
            result += node.value;
            
            // Add subscript/superscript for symbols
            if (node.subscript) {
                const subContent = astToUnicodeMath(node.subscript, context);
                result += `_${subContent} `;
            }
            if (node.superscript) {
                const supContent = astToUnicodeMath(node.superscript, context);
                result += `^(${supContent}) `;
            }
            break;
            
        case 'operator':
            result += ` ${node.value} `;
            break;
            
        case 'lparen':
            result += '(';
            break;
            
        case 'rparen':
            result += ')';
            break;
            
        case 'char':
            result += node.value;
            break;
            
        case 'command':
            result += processCommand(node, context);
            break;
            
        default:
            if (node.value) {
                result += node.value;
            }
    }
    
    return result;
}

/**
 * Process LaTeX commands
 */
function processCommand(node, context) {
    const cmd = node.value;
    const args = node.args || [];
    
    // Arrow commands
    if (cmd === '\\rightarrow' || cmd === '\\to') {
        return ' → ';
    }
    if (cmd === '\\leftarrow') {
        return ' ← ';
    }
    if (cmd === '\\leftrightarrow') {
        return ' ↔ ';
    }
    if (cmd === '\\rightleftharpoons' || cmd === '\\leftharpoons') {
        return ' ⇌ ';
    }
    if (cmd === '\\Rightarrow' || cmd === '\\implies') {
        return ' ⇒ ';
    }
    if (cmd === '\\Leftarrow') {
        return ' ⇐ ';
    }
    if (cmd === '\\Leftrightarrow' || cmd === '\\iff') {
        return ' ⇔ ';
    }
    
    // Labeled arrows
    if (cmd === '\\xrightarrow') {
        const label = args[0] ? cleanSegment(args[0]) : '';
        if (label) {
            return ` □(→┴${label} ) `;
        }
        return ' → ';
    }
    if (cmd === '\\xleftarrow') {
        const label = args[0] ? cleanSegment(args[0]) : '';
        if (label) {
            return ` □(←┴${label} ) `;
        }
        return ' ← ';
    }
    
    // Greek letters
    const greekMap = {
        '\\alpha': 'α', '\\beta': 'β', '\\gamma': 'γ', '\\delta': 'δ', '\\Delta': 'Δ',
        '\\epsilon': 'ε', '\\varepsilon': 'ε', '\\theta': 'θ', '\\Theta': 'Θ',
        '\\lambda': 'λ', '\\Lambda': 'Λ', '\\mu': 'μ', '\\pi': 'π', '\\Pi': 'Π',
        '\\sigma': 'σ', '\\Sigma': 'Σ', '\\phi': 'φ', '\\Phi': 'Φ', '\\omega': 'ω', '\\Omega': 'Ω'
    };
    if (greekMap[cmd]) {
        return greekMap[cmd];
    }
    
    // Math operators
    if (cmd === '\\pm') return '±';
    if (cmd === '\\times') return '×';
    if (cmd === '\\cdot') return '·';
    if (cmd === '\\div') return '÷';
    
    // Fractions
    if (cmd === '\\frac') {
        const num = args[0] ? cleanSegment(args[0]) : '';
        const den = args[1] ? cleanSegment(args[1]) : '';
        return `${num}⁄${den}`;
    }
    
    // Square root
    if (cmd === '\\sqrt') {
        const content = args[0] ? cleanSegment(args[0]) : '';
        return `√(${content})`;
    }
    
    // Text commands
    if (cmd === '\\text' || cmd === '\\mathrm' || cmd === '\\operatorname') {
        return args[0] || '';
    }
    
    // Decorations
    if (cmd === '\\overline') {
        const content = args[0] ? cleanSegment(args[0]) : '';
        return `${content}̅`;
    }
    if (cmd === '\\bar') {
        const content = args[0] ? cleanSegment(args[0]) : '';
        return `${content}̄`;
    }
    if (cmd === '\\hat') {
        const content = args[0] ? cleanSegment(args[0]) : '';
        return `${content}̂`;
    }
    if (cmd === '\\tilde') {
        const content = args[0] ? cleanSegment(args[0]) : '';
        return `${content}̃`;
    }
    if (cmd === '\\vec') {
        const content = args[0] ? cleanSegment(args[0]) : '';
        return `${content}⃗`;
    }
    
    // Placeholder
    if (cmd === '\\placeholder') {
        return '□';
    }
    
    // Font commands
    if (cmd === '\\mathbb' || cmd === '\\mathcal' || cmd === '\\mathfrak') {
        return args[0] || '';
    }
    
    // Spacing commands - ignore
    if (cmd === '\\!' || cmd === '\\,' || cmd === '\\;' || cmd === '\\:' || 
        cmd === '\\quad' || cmd === '\\qquad') {
        return '';
    }
    
    // Unknown command - return the name
    return cmd.substring(1); // Remove backslash
}

/**
 * Main conversion function using AST
 */
function toWordEquation(latex) {
    if (!latex || !latex.trim()) {
        return '';
    }
    
    // Pre-processing: clean up the LaTeX
    let processed = latex;
    
    // Remove \! spacing commands
    processed = processed.replace(/\\!/g, '');
    
    // Handle state symbols - convert to inline parentheses
    processed = processed.replace(/_\{\\?\(?text\{(aq|s|l|g)\}\)?\}/gi, '((${1}))');
    processed = processed.replace(/_\{\\?\(?(aq|s|l|g)\)?\}/gi, '(($1))');
    
    // Tokenize
    const tokens = tokenizeLatex(processed);
    
    // Parse to AST
    const ast = parseToAST(tokens);
    
    // Convert to UnicodeMath
    let result = astToUnicodeMath(ast);
    
    // Post-processing
    result = postProcess(result);
    
    return result;
}

/**
 * Post-processing cleanup
 */
function postProcess(text) {
    // Replace state markers with proper format
    text = text.replace(/\(\((aq|s|l|g)\)\)/gi, (_, state) => `(${state.toLowerCase()})`);
    
    // Clean up multiple spaces
    text = text.replace(/\s{3,}/g, '  ');
    
    // Ensure space before opening parenthesis for states
    text = text.replace(/([A-Za-z0-9〗])\s*\(([aslg])\)/g, '$1 ($2)');
    
    // Clean up space before operators
    text = text.replace(/\s+([+])\s+/g, ' $1 ');
    
    // Trim
    text = text.trim();
    
    return text;
}

/**
 * Legacy cleanSegment function for command arguments
 */
function cleanSegment(segment, depth = 0) {
    if (depth > 5) return segment || '';
    
    let text = String(segment || '').trim();
    if (!text) return '';
    
    // Remove braces
    text = text.replace(/[{}]/g, '');
    
    // Process nested LaTeX
    const tokens = tokenizeLatex(text);
    const ast = parseToAST(tokens);
    text = astToUnicodeMath(ast);
    
    return text.trim();
}

function syncFromMath(){
  const val = mathField.getValue('latex') || '';
  
  // Store raw version WITH \!
  rawLatex = val;
  
  // Display version WITHOUT \! in text area
  textArea.value = val.replace(/\\!/g, '');
  
  // Generate word equation from version WITH \!
  wordOutput.value = toWordEquation(rawLatex);
  
  // Preview also WITHOUT \!
  const previewVal = val.replace(/\\!/g, '');
  previewDiv.innerHTML = '$$' + previewVal + '$$';
  typesetMath();
}

function syncFromText(){
  let val = textArea.value;
  
  // Auto-wrap single capital letters (optionally followed by lowercase) before subscripts/superscripts
  // This converts patterns like "A_1" to "{A}_1" and "Ca_2" to "{Ca}_2"
  val = val.replace(/\b([A-Z][a-z]?)(?=[\^_])/g, '{$1}');
  
  // Store as raw (user edits don't include \! since they can't see it)
  rawLatex = val;
  
  // Generate word equation from the raw version
  wordOutput.value = toWordEquation(rawLatex);
  
  // Preview WITHOUT \!
  const previewVal = val.replace(/\\!/g, '');
  previewDiv.innerHTML = '$$' + previewVal + '$$';
  typesetMath();
  mathField.setValue(val);
}

// Fixed regex to match the actual state format: _{(state)}
const stateRegex = /_\{\((?:s|l|g|aq)\)\}$/;

function setupMathField(){
  mathField.setOptions({
    virtualKeyboardMode:'off',
    inlineShortcuts:{},
    overrideDefaultInlineShortcuts:true,
    mathModeSpace: '\\:'
  });
  mathField.addEventListener('input', syncFromMath);
  textArea.addEventListener('input', syncFromText);

  mathField.addEventListener('keydown', (e)=>{
    // Keep typing inside superscripts/subscripts until explicitly exited
    if(e.key === '^'){
      e.preventDefault();
      insertText('^{\\placeholder{}}');
      return;
    }
    if(e.key === '_'){
      e.preventDefault();
      insertText('_{\\placeholder{}}');
      return;
    }
    
    const latex = mathField.getValue('latex') || '';
    
    // Auto-advance to superscript after completing numeric subscript
    // When typing a letter after _{digits}, insert ^{} first
    if(/^[A-Za-z]$/.test(e.key)){
      // Check if we're right after a numeric subscript: ..._{digits}|
      const match = latex.match(/_{(\d+)}$/);
      if(match){
        e.preventDefault();
        mathField.insert(`^{\\placeholder{}}${e.key}`);
        return;
      }
    }
    
    if(e.key !== 'Backspace' && e.key !== 'Delete') return;
    
    // Get cursor position
    const position = mathField.offsetOf(mathField.model.at(mathField.model.position));
    
    if(e.key === 'Backspace'){
      // Check if there's a state pattern before the cursor
      const beforeCursor = latex.substring(0, position);
      // Match states like _{(s)}, _{(l)}, _{(g)}, _{(aq)}
      const stateMatch = beforeCursor.match(/_\{\\?\(?(?:s|l|g|aq)\)?\}$/);
      if(stateMatch){
        e.preventDefault();
        const newLatex = beforeCursor.substring(0, beforeCursor.length - stateMatch[0].length) + latex.substring(position);
        mathField.setValue(newLatex);
        // Set cursor position after deletion
        mathField.executeCommand(['performWithFeedback', 'moveToMathFieldEnd']);
        mathField.executeCommand(['performWithFeedback', 'moveToPreviousChar']);
        for(let i = 0; i < (latex.substring(position).length); i++){
          mathField.executeCommand(['performWithFeedback', 'moveToPreviousChar']);
        }
        syncFromMath();
        return;
      }
    }
    
    if(e.key === 'Delete'){
      // Check if there's a state pattern after the cursor
      const afterCursor = latex.substring(position);
      // Match states like _{(s)}, _{(l)}, _{(g)}, _{(aq)}
      const stateMatch = afterCursor.match(/^_\{\\?\(?(?:s|l|g|aq)\)?\}/);
      if(stateMatch){
        e.preventDefault();
        const newLatex = latex.substring(0, position) + afterCursor.substring(stateMatch[0].length);
        mathField.setValue(newLatex);
        // Restore cursor position
        mathField.executeCommand(['performWithFeedback', 'moveToMathFieldStart']);
        for(let i = 0; i < position; i++){
          mathField.executeCommand(['performWithFeedback', 'moveToNextChar']);
        }
        syncFromMath();
        return;
      }
    }
  });

  textArea.addEventListener('keydown', (e)=>{
    if(e.key !== 'Backspace' && e.key !== 'Delete') return;
    const v = textArea.value || '';
    const cursorPos = textArea.selectionStart;
    
    if(e.key === 'Backspace'){
      // Check if there's a state pattern before the cursor
      const beforeCursor = v.substring(0, cursorPos);
      const stateMatch = beforeCursor.match(/_\{\\?\(?(?:s|l|g|aq)\)?\}$/);
      if(stateMatch){
        e.preventDefault();
        const result = beforeCursor.substring(0, beforeCursor.length - stateMatch[0].length) + v.substring(cursorPos);
        textArea.value = result;
        const newPos = cursorPos - stateMatch[0].length;
        textArea.setSelectionRange(newPos, newPos);
        syncFromText();
      }
    }
    
    if(e.key === 'Delete'){
      // Check if there's a state pattern after the cursor
      const afterCursor = v.substring(cursorPos);
      const stateMatch = afterCursor.match(/^_\{\\?\(?(?:s|l|g|aq)\)?\}/);
      if(stateMatch){
        e.preventDefault();
        const result = v.substring(0, cursorPos) + afterCursor.substring(stateMatch[0].length);
        textArea.value = result;
        textArea.setSelectionRange(cursorPos, cursorPos);
        syncFromText();
      }
    }
  });

  mathField.focus();
  syncFromMath();
}

function applyState(state){
  // 简单插入状态占位符
  mathField.insert(`_{(\\text{${state}})}`);
  syncFromMath();
}

function insertText(text){ mathField.insert(text); syncFromMath(); }

const chemKeys = [
  { display: '\\rightarrow', insert: ' \\rightarrow ' },
  { display: '\\rightleftharpoons', insert: ' \\rightleftharpoons ' },
  { display: '\\xrightarrow{\\placeholder{}}', insert: ' \\xrightarrow{\\placeholder{}\\!} ' },
  { display: '{\\placeholder{}}_{(s)}', insert: '{\\placeholder{}\\!}_{(s)}' },
  { display: '{\\placeholder{}}_{(l)}', insert: '{\\placeholder{}\\!}_{(l)}' },
  { display: '{\\placeholder{}}_{(g)}', insert: '{\\placeholder{}\\!}_{(g)}' },
  { display: '{\\placeholder{}}_{(aq)}', insert: '{\\placeholder{}\\!}_{(aq)}' },
  { display: '{{\\placeholder{}}^{\\placeholder{}}}_{(aq)}', insert: '{{\\placeholder{}\\!}^{\\placeholder{}}}_{(aq)}' },
  { display: '{\\placeholder{}}^{\\placeholder{}}', insert: '{\\placeholder{}\\!}^{\\placeholder{}}' },
  { display: '\\xrightarrow{\\Delta}', insert: ' \\xrightarrow{\\Delta} ' },
  { display: '^{\\placeholder{}}_{\\placeholder{}}\\placeholder{}', insert: '^{\\placeholder{}}_{\\placeholder{}}\\placeholder{}' },
  { display: '\\alpha', insert: '\\alpha' },
  { display: '\\beta', insert: '\\beta' },
  { display: '\\gamma', insert: '\\gamma' },
  { display: '\\overline{\\beta}\\:', insert: '\\overline{\\beta}\\:' }
];

function buildKeys(){
  const container = document.getElementById('keyboard');
  container.innerHTML = '';
  chemKeys.forEach(key => {
    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'key';
    button.innerHTML = '$$' + key.display + '$$';
    button.addEventListener('click', () => { if(key.action) key.action(); else insertText(key.insert); });
    container.appendChild(button);
  });
  if(window.MathJax) window.MathJax.typesetPromise([container]);
}

(async()=>{
  const urls = ['https://cdn.jsdelivr.net/npm/mathlive/dist/mathlive.min.js','https://unpkg.com/mathlive/dist/mathlive.min.js'];
  let mathLiveLoaded = false;
  
  for(const url of urls){
    try{
      await new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = url; 
        script.defer = true; 
        script.onload = () => {
          mathLiveLoaded = true;
          resolve();
        }; 
        script.onerror = reject;
        document.head.appendChild(script);
      });
      break;
    }catch(e){
      console.warn('Failed to load MathLive from', url, e);
    }
  }
  
  // Wait for MathLive to be defined
  if(window.customElements && window.customElements.whenDefined) {
    try {
      await customElements.whenDefined('math-field');
    } catch(e) {
      console.warn('MathLive custom element not defined', e);
    }
  }
  
  // Setup regardless of MathLive status
  setupMathField();
  buildKeys();
})();

document.getElementById('copyLatex').addEventListener('click', () => {
  // Remove \! from copied LaTeX
  const cleanLatex = textArea.value.replace(/\\!/g, '');
  copyToClipboard(cleanLatex, 'LaTeX');
});

document.getElementById('copyWordBtn').addEventListener('click', () => {
  copyToClipboard(wordOutput.value, 'word equation');
});

document.getElementById('headerCopyLatex').addEventListener('click', () => {
  // Remove \! from copied LaTeX
  const cleanLatex = textArea.value.replace(/\\!/g, '');
  copyToClipboard(cleanLatex, 'LaTeX');
});

document.getElementById('headerCopyWord').addEventListener('click', () => {
  copyToClipboard(wordOutput.value, 'word equation');
});
</script>

<div id="toast" role="status" aria-live="polite"></div>
</body>
</html>
