<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
<meta charset="utf-8" />
<title>HSC Chemistry â€“ Equation Typer (with Isotopes)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<script src="https://unpkg.com/lucide@latest"></script>
<style>
:root {
  color-scheme: light;
  --page-max-width: 1200px;
  --page-pad-x: 24px;
  --content-max: var(--page-max-width);
  --content-pad-x: var(--page-pad-x);
  --bg: #f8fafc;
  --card: #ffffff;
  --ink: #111827;
  --muted: #6b7280;
  --brand: #2563eb;
  --brand-ink: #ffffff;
  --border: #e2e8f0;
  --key-bg: rgba(255, 255, 255, 0.9);
  --copy-bg: #ffffff;
  --copy-border: rgba(15, 23, 42, 0.15);
  --copy-ink: #0f172a;
  --copy-hover-bg: var(--brand);
  --copy-hover-ink: var(--brand-ink);
  --copy-hover-border: rgba(37, 99, 235, 0.65);
  --color-header-bg: var(--brand);
  --color-header-text: var(--brand-ink);
  --color-surface: var(--card);
  --color-border: var(--border);
  --color-tab-active-bg: var(--brand);
  --color-tab-active-text: var(--brand-ink);
  --wallpaper-light: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='28' height='28' viewBox='0 0 28 28'><rect width='100%' height='100%' fill='none'/><circle cx='14' cy='14' r='0.75' fill='%23cbd5e1' opacity='0.55'/></svg>");
  --wallpaper-dark: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='28' height='28' viewBox='0 0 28 28'><rect width='100%' height='100%' fill='none'/><circle cx='14' cy='14' r='0.75' fill='%23334155' opacity='0.55'/></svg>");
  --wallpaper: var(--wallpaper-light);
  --scale: 1.1;
}
[data-theme="dark"] {
  color-scheme: dark;
  --bg: #0f172a;
  --card: #1e293b;
  --ink: #e2e8f0;
  --muted: #94a3b8;
  --brand: #1d4ed8;
  --brand-ink: #f8fafc;
  --border: #334155;
  --key-bg: rgba(30, 41, 59, 0.9);
  --copy-bg: rgba(15, 23, 42, 0.85);
  --copy-border: rgba(148, 163, 184, 0.45);
  --copy-ink: #f8fafc;
  --copy-hover-bg: var(--brand);
  --copy-hover-ink: var(--brand-ink);
  --copy-hover-border: rgba(37, 99, 235, 0.65);
  --color-header-bg: var(--brand);
  --color-header-text: var(--brand-ink);
  --color-surface: var(--card);
  --color-border: var(--border);
  --color-tab-active-bg: var(--brand);
  --color-tab-active-text: var(--brand-ink);
  --wallpaper: var(--wallpaper-dark);
}
* {
  box-sizing: border-box;
}
html, body { overflow: hidden; overscroll-behavior: none; touch-action: pan-y; }
body {
  font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Ubuntu, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif;
  margin: 0;
  background: var(--bg);
  color: var(--ink);
  transition: background 0.3s ease, color 0.3s ease;
  font-size: calc(16px * var(--scale));
}
header {
  padding: calc(12px * var(--scale)) 0;
  background: linear-gradient(135deg, #2563eb, #3b82f6 60%, #6366f1);
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
}
.header-inner {
  width: 100%;
  max-width: var(--page-max-width);
  margin: 0 auto;
  padding: 0 var(--page-pad-x);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: calc(12px * var(--scale));
}
header h1 {
  font-size: calc(18px * var(--scale));
  margin: 0;
  font-weight: 700;
  color: #ffffff;
}
header .header-left {
  display: flex;
  align-items: center;
  gap: calc(12px * var(--scale));
  flex-wrap: wrap;
}
.header-actions {
  display: flex;
  gap: calc(12px * var(--scale));
  flex-wrap: wrap;
}
.header-controls {
  display: flex;
  align-items: center;
  gap: calc(16px * var(--scale));
}
#status {
  font-size: calc(14px * var(--scale));
  font-weight: 600;
  opacity: 0.95;
  color: var(--brand-ink);
}
.visually-hidden {
  position: absolute !important;
  height: 1px;
  width: 1px;
  overflow: hidden;
  clip: rect(1px, 1px, 1px, 1px);
  white-space: nowrap;
  border: 0;
  padding: 0;
  margin: -1px;
}
.theme-switch{
  display: flex;
  align-items: center;
  gap: 4px;
}
.theme-opt{
  appearance: none;
  min-height: 36px;
  min-width: 36px;
  padding: 6px;
  border-radius: 8px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  background: transparent;
  border: none;
  color: rgba(255, 255, 255, 0.85);
  cursor: pointer;
  transition: all 0.2s ease;
}
.theme-opt.is-active{
  background: rgba(255, 255, 255, 0.2);
  color: rgba(255, 255, 255, 1);
}
.theme-opt:hover{ 
  background: rgba(255, 255, 255, 0.15);
  color: rgba(255, 255, 255, 1);
}
.theme-opt:active {
  background: rgba(255, 255, 255, 0.25);
}
.theme-opt svg {
  width: 18px;
  height: 18px;
  display: block;
  stroke: currentColor;
  stroke-width: 2;
  fill: none;
  transition: transform 0.2s ease;
}
.theme-opt:hover svg {
  transform: scale(1.1);
}
main {
  width: 100%;
  max-width: var(--content-max);
  margin-left: auto;
  margin-right: auto;
  margin-top: calc(18px * var(--scale));
  margin-bottom: calc(18px * var(--scale));
  padding-left: var(--content-pad-x);
  padding-right: var(--content-pad-x);
  padding-bottom: calc(24px * var(--scale));
  display: grid;
  gap: calc(12px * var(--scale));
}
.panel,
.card {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: calc(12px * var(--scale));
  overflow: hidden;
  box-shadow: 0 1px 1px rgba(15, 23, 42, 0.06);
}
.panel .head {
  padding: calc(10px * var(--scale)) calc(12px * var(--scale));
  border-bottom: 1px solid var(--border);
  font-weight: 600;
  display: flex;
  justify-content: center;
  align-items: center;
  color: var(--ink);
  text-align: center;
}
.panel .body,
.card .body {
  padding: calc(12px * var(--scale));
}
math-field,
textarea {
  font-size: calc(18px * var(--scale));
  padding: calc(10px * var(--scale));
  border: 1px solid var(--border);
  border-radius: calc(10px * var(--scale));
  background: var(--card);
  color: var(--ink);
  width: 100%;
  transition: border-color 0.2s ease, background 0.2s ease;
}
math-field {
  min-height: calc(52px * var(--scale));
}
textarea {
  min-height: calc(52px * var(--scale));
  resize: none;
}
#ta {
  min-height: calc(52px * var(--scale));
}
.preview-card .body {
  padding: 0;
}
#preview {
  min-height: calc(52px * var(--scale));
  padding: calc(16px * var(--scale));
}
.row {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: calc(10px * var(--scale));
  align-items: center;
}
.btn {
  padding: calc(4px * var(--scale)) calc(8px * var(--scale));
  border: 1px solid var(--border);
  border-radius: calc(6px * var(--scale));
  background: var(--card);
  cursor: pointer;
  font-size: calc(12px * var(--scale));
  color: var(--ink);
}
.btn:active {
  transform: translateY(calc(1px * var(--scale)));
}
.btn:focus-visible {
  outline: calc(2px * var(--scale)) solid var(--brand);
  outline-offset: calc(2px * var(--scale));
}
.btn:hover,
.btn:focus-visible {
  background: var(--copy-hover-bg);
  border-color: var(--copy-hover-border);
  color: var(--copy-hover-ink);
}
.copyBtn,
.header-copy {
  appearance: none;
  align-items: center;
  justify-content: center;
  display: inline-flex;
  gap: calc(6px * var(--scale));
  padding: calc(8px * var(--scale)) calc(18px * var(--scale));
  border-radius: calc(999px * var(--scale));
  border: 1px solid var(--copy-border);
  background: var(--copy-bg);
  color: var(--copy-ink);
  font-size: 1em;
  font-weight: 600;
  cursor: pointer;
  letter-spacing: -0.01em;
  box-shadow: 0 calc(6px * var(--scale)) calc(18px * var(--scale)) rgba(15, 23, 42, 0.25);
  transition: background 0.18s ease, color 0.18s ease, box-shadow 0.18s ease, transform 0.12s ease, border-color 0.18s ease;
}
.copyBtn {
  font-size: calc(12px * var(--scale));
}
.header-copy {
  appearance: none;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 11px 24px;
  border-radius: 999px;
  background-color: #ffffff;
  border: none;
  color: #1e293b;
  font-weight: 700;
  font-size: 15px;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15), 0 1px 3px rgba(0, 0, 0, 0.1);
}
.copyBtn:hover,
.copyBtn:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--copy-bg));
  border-color: var(--color-tab-active-bg);
  box-shadow: 0 6px 16px rgba(37, 99, 235, 0.25);
  transform: translateY(-1px);
}
.header-copy:hover {
  transform: translateY(-1px);
}
.header-copy:focus-visible {
  background-color: #f8fafc;
  outline: 2px solid rgba(255, 255, 255, 0.5);
  outline-offset: 2px;
  transform: translateY(-1px);
}

[data-theme="dark"] .header-copy:focus-visible {
  background-color: var(--card) !important;
  outline: 2px solid rgba(255, 255, 255, 0.3);
}
.copyBtn:focus-visible {
  outline: calc(2px * var(--scale)) solid rgba(37, 99, 235, 0.6);
  outline-offset: calc(2px * var(--scale));
}
.copyBtn:active {
  box-shadow: 0 calc(2px * var(--scale)) calc(8px * var(--scale)) rgba(15, 23, 42, 0.25);
}
.header-copy:active {
  background-color: #e2e8f0;
  transform: translateY(0);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

[data-theme="dark"] .header-copy:active {
  background-color: var(--card) !important;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

/* Dark mode header buttons */
[data-theme="dark"] .header-copy {
  background-color: var(--card) !important;
  border: 1px solid var(--border) !important;
  color: var(--ink) !important;
}

[data-theme="dark"] .header-copy:hover {
  background: #1d4ed8 !important;
  border-color: #1d4ed8 !important;
  box-shadow: 0 6px 16px rgba(37, 99, 235, 0.25) !important;
  transform: translateY(-1px) !important;
}
#keyboard {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(0, 1fr));
  gap: calc(8px * var(--scale));
  width: 100%;
}
.key {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: calc(48px * var(--scale));
  padding: calc(6px * var(--scale)) calc(12px * var(--scale));
  background: var(--key-surface);
  border: 1px solid var(--key-border);
  border-radius: calc(6px * var(--scale));
  cursor: pointer;
  font-size: calc(13px * var(--scale));
  width: 100%;
  color: var(--ink);
  transition: background 0.18s ease, color 0.18s ease, border-color 0.18s ease, box-shadow 0.18s ease, transform 0.12s ease;
}
.key mjx-container {
  font-size: calc(20px * var(--scale));
  max-width: 100%;
}
.key:hover,
.key:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--key-surface));
  border-color: var(--color-tab-active-bg);
  transform: translateY(calc(-1px * var(--scale)));
}
.key:active {
  transform: translateY(calc(1px * var(--scale)));
}
.hint { font-size: calc(12px * var(--scale)); color: var(--muted); margin-top: calc(4px * var(--scale)); }
.editor {
  display: grid;
  gap: calc(6px * var(--scale));
}
.editor label {
  display: flex;
  align-items: center;
  gap: calc(8px * var(--scale));
  font-size: calc(13px * var(--scale));
  color: var(--muted);
}
.editor label strong {
  font-weight: 600;
  color: var(--ink);
}
.editor .copyBtn {
  margin-left: auto;
}
.stack {
  display: grid;
  gap: calc(16px * var(--scale));
}
math-field::part(virtual-keyboard-toggle),
math-field::part(menu-toggle),
math-field::part(toolbar) {
  display: none !important;
}

/* === Pretty-up pack (drop-in overrides) === */

/* Font & smoother text rendering */
html, body {
  font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Subtle gradient background that adapts to theme */
:root {
  --bg-grad-1: radial-gradient(1200px 600px at 10% -10%, rgba(37, 99, 235, 0.10), transparent 60%),
               radial-gradient(900px 500px at 110% 10%, rgba(99, 102, 241, 0.10), transparent 60%);
}
[data-theme="dark"] {
  --bg-grad-1: radial-gradient(1200px 600px at 10% -10%, rgba(37, 99, 235, 0.18), transparent 60%),
               radial-gradient(900px 500px at 110% 10%, rgba(99, 102, 241, 0.18), transparent 60%);
}
body {
  background-image: var(--bg-grad-1), var(--wallpaper);
  background-size: auto, 28px 28px;
  background-attachment: fixed, fixed;
  background-position: center, center;
  background-repeat: no-repeat, repeat;
}

/* Header glow-up */
header {
  background: linear-gradient(135deg, var(--color-header-bg), #3b82f6 55%, #6366f1);
  box-shadow: 0 8px 20px rgba(2, 6, 23, 0.28);
}
header h1 {
  letter-spacing: -0.01em;
  font-size: 20px;
  line-height: 1.2;
  position: relative;
}
header h1::after {
  content: "";
  position: absolute;
  left: 0; bottom: -6px;
  width: 100px; height: 3px;
  border-radius: 999px;
  background: linear-gradient(90deg, #ffffffaa, #c7d2fe 60%, transparent);
  filter: blur(.3px);
}

/* Panels & cards with glassy feel */
.panel,
.card {
  border-radius: 18px;
  backdrop-filter: saturate(1.1) blur(6px);
  background: color-mix(in srgb, var(--color-surface) 86%, transparent);
  border: 1px solid color-mix(in srgb, var(--color-border) 70%, transparent);
  transition: transform .15s ease, box-shadow .2s ease, background .2s ease, border-color .2s ease;
}
.panel:hover,
.card:hover {
  transform: none;
  box-shadow: 0 16px 30px rgba(8, 15, 35, 0.18);
  background: color-mix(in srgb, var(--color-surface) 92%, transparent);
}

/* Inputs: clearer focus ring */
math-field, textarea {
  border-radius: 10px;
  box-shadow: 0 1px 0 rgba(2, 6, 23, 0.04);
}
math-field:focus-within, textarea:focus {
  outline: 2px solid color-mix(in srgb, var(--color-tab-active-bg) 60%, white);
  outline-offset: 2px;
  border-color: var(--color-tab-active-bg);
}

/* Preview surface */
#preview {
  border-radius: 14px;
  background: color-mix(in srgb, var(--color-surface) 92%, transparent);
  border: 1px solid color-mix(in srgb, var(--color-border) 70%, transparent);
}

/* Copy buttons */
.copyBtn, .header-copy {
  letter-spacing: 0;
  border-radius: 12px;
  padding: 9px 18px;
  box-shadow: 0 10px 24px rgba(2, 6, 23, 0.2);
}

/* Keyboard keys */
.key {
  border-radius: 14px;
  box-shadow: 0 10px 22px rgba(2, 6, 23, 0.12);
  transition: transform .12s ease, box-shadow .12s ease, background-color .2s ease, border-color .2s ease;
}


/* === Copy toast styles === */
#toast {
  position: fixed;
  left: 50%;
  bottom: 40px;
  transform: translateX(-50%) translateY(40px);
  background: rgba(34,197,94,0.95); /* green success */
  color: #fff;
  padding: 10px 18px;
  border-radius: 999px;
  font-size: 14px;
  font-weight: 700;
  letter-spacing: 0.01em;
  box-shadow: 0 12px 28px rgba(2,6,23,0.25);
  opacity: 0;
  pointer-events: none;
  transition: opacity .25s ease, transform .25s ease;
  z-index: 9999;
}
#toast.show {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}

/* Responsive styles for smaller screens */
@media (max-width: 640px) {
  :root {
    --page-pad-x: 16px;
    --content-pad-x: var(--page-pad-x);
  }
}

/* === EXACT Ext2 key glow â€“ copied verbatim === */
/* Tokens used by Ext2 keys */
:root {
  --key-surface: rgba(255, 255, 255, 0.96);
  --key-border: rgba(148, 163, 184, 0.38);
}
[data-theme="dark"] {
  --key-surface: rgba(30, 44, 76, 0.92);
  --key-border: rgba(84, 105, 150, 0.55);
}

/* Base key look from Ext2 */
.key {
  border-radius: 14px;
  border: 1px solid var(--key-border);
  background: var(--key-surface);
  box-shadow: 0 10px 22px rgba(2, 6, 23, 0.12);
  transition:
    transform .12s ease,
    box-shadow .12s ease,
    background-color .2s ease,
    border-color .2s ease;
}

/* Ext2 hover (no ring/filter, fixed -1px lift, specific shadow) */
.key:hover,
.key:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--key-surface));
  border-color: var(--color-tab-active-bg);
  transform: translateY(-1px);
  box-shadow: 0 12px 22px rgba(15, 23, 42, 0.18);
  filter: none;
  outline: none;
}

/* === TABS SECTION === */
.tab {
  padding: 10px 16px;
  border: 1px solid var(--color-border);
  border-radius: 12px;
  cursor: pointer;
  background: var(--color-tab-bg);
  color: var(--color-tab-text);
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  font-size: 12px;
  font-weight: 600;
  transition: background .2s ease, border-color .2s ease, box-shadow .2s ease, transform .15s ease;
  flex: 1;
  min-width: 0;
  text-align: center;
  width: 100%;
  max-width: none;
}

/* === EXT2-style hover glow for Chemistry tabs === */
.tab:hover,
.tab:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--color-tab-bg));
  border-color: var(--color-tab-active-bg);
  transform: translateY(-1px);
  box-shadow: 0 12px 22px rgba(15, 23, 42, 0.18);
  filter: drop-shadow(0 0 10px rgba(37,99,235,0.35));
}

/* === Ext2-identical header button glow (light & dark) === */
.header-copy {
  border: 1px solid var(--copy-border);
  background: var(--copy-bg);
  color: var(--copy-ink);
  box-shadow: 0 6px 18px rgba(15, 23, 42, 0.25);
  transition: background .18s ease, color .18s ease, box-shadow .18s ease, transform .12s ease, border-color .18s ease;
}
.header-copy:hover,
.header-copy:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--copy-bg));
  border-color: var(--color-tab-active-bg);
  box-shadow: 0 6px 16px rgba(37, 99, 235, 0.25);
  transform: translateY(-1px);
  outline: 2px solid rgba(37, 99, 235, 0.6);
  outline-offset: 2px;
}
.header-copy:active { box-shadow: 0 2px 8px rgba(15, 23, 42, 0.25); transform: translateY(0); }

/* Dark mode: apply the exact same recipe (tokens swap under dark) */
[data-theme="dark"] .header-copy,
[data-theme="dark"] .header-copy:hover,
[data-theme="dark"] .header-copy:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--copy-bg));
  /* ensure border/ink come from the same token set Ext2 uses */
  border-color: var(--color-tab-active-bg);
  color: var(--copy-ink);
  box-shadow: 0 6px 16px rgba(37, 99, 235, 0.25);
}

/* === EXT2-EXACT GLOW for keys + header buttons (light & dark) === */
/* Key base (from Ext2) */
.key {
  border-radius: 14px;
  border: 1px solid var(--key-border);
  background: var(--key-surface);
  box-shadow: 0 10px 22px rgba(2, 6, 23, 0.12);
  transition: transform .12s ease, box-shadow .12s ease, background-color .2s ease, border-color .2s ease;
}
/* Key hover: no neon ring, exact tint + lift + shadow */
.key:hover,
.key:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--key-surface));
  border-color: var(--color-tab-active-bg);
  transform: translateY(-1px);
  box-shadow: 0 12px 22px rgba(15, 23, 42, 0.18);
  outline: none;
  filter: none;
}
/* Kill any previous outlines/rings that caused the blue "neon" look */
.key:focus { outline: none; }

/* Header buttons base (match Ext2) */
.header-copy {
  border: 1px solid var(--copy-border);
  background: var(--copy-bg);
  color: var(--copy-ink);
  box-shadow: 0 6px 18px rgba(15, 23, 42, 0.25);
  transition: background .18s ease, color .18s ease, box-shadow .18s ease, transform .12s ease, border-color .18s ease;
}
/* Header buttons hover/focus: exact Ext2 recipe */
.header-copy:hover,
.header-copy:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--copy-bg));
  border-color: var(--color-tab-active-bg);
  box-shadow: 0 6px 16px rgba(37, 99, 235, 0.25);
  transform: translateY(-1px);
  outline: 2px solid rgba(37, 99, 235, 0.6);
  outline-offset: 2px;
  color: var(--color-tab-active-text);
}
.header-copy:active { box-shadow: 0 2px 8px rgba(15, 23, 42, 0.25); transform: translateY(0); }
.header-copy svg { stroke: currentColor; }

/* Dark mode: remove Chem overrides that broke Ext2 glow */
[data-theme="dark"] .header-copy,
[data-theme="dark"] .header-copy:hover,
[data-theme="dark"] .header-copy:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--copy-bg));
  border-color: var(--color-tab-active-bg);
  color: var(--color-tab-active-text);
  box-shadow: 0 6px 16px rgba(37, 99, 235, 0.25);
}

/* === EXT2-identical header buttons (light & dark) === */
.header-copy {
  border: 1px solid var(--copy-border) !important;
  background: var(--copy-bg) !important;
  color: var(--copy-ink) !important;
  box-shadow: 0 6px 18px rgba(15, 23, 42, 0.25) !important;
  transition: background .18s ease, color .18s ease,
              box-shadow .18s ease, transform .12s ease,
              border-color .18s ease !important;
}

.header-copy:hover,
.header-copy:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--copy-bg)) !important;
  border-color: var(--color-tab-active-bg) !important;
  box-shadow: 0 6px 16px rgba(37, 99, 235, 0.25) !important;
  transform: translateY(-1px) !important;
  outline: 2px solid rgba(37, 99, 235, 0.6) !important;
  outline-offset: 2px !important;
}

.header-copy:active {
  box-shadow: 0 2px 8px rgba(15, 23, 42, 0.25) !important;
  transform: translateY(0) !important;
}

/* ensure icons follow text color like Ext2 */
.header-copy svg { stroke: currentColor; }

/* === ChemistryTyper header buttons with E2-style dark glow === */
.header-actions .header-copy {
  border: 1px solid var(--copy-border);
  background: var(--copy-bg);
  color: var(--copy-ink);
  border-radius: 999px;
  box-shadow: 0 8px 20px rgba(2, 6, 23, 0.15);
  transition:
    background 0.18s ease,
    border-color 0.18s ease,
    box-shadow 0.18s ease,
    transform 0.12s ease,
    color 0.18s ease;
}

/* --- Hover / Focus: exact E2 blue highlight --- */
.header-actions .header-copy:hover,
.header-actions .header-copy:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--copy-bg));
  border-color: var(--color-tab-active-bg);
  transform: translateY(-1px);
  box-shadow:
    0 8px 20px rgba(37, 99, 235, 0.25),
    0 0 30px rgba(37, 99, 235, 0.3);
  outline: none;
  color: var(--copy-ink);
}

/* --- Active press --- */
.header-actions .header-copy:active {
  transform: translateY(0);
  box-shadow: 0 4px 10px rgba(37, 99, 235, 0.2);
}

/* --- Dark mode --- */
[data-theme="dark"] .header-actions .header-copy {
  background: var(--copy-bg);
  border: 1px solid var(--copy-border);
  color: var(--copy-ink);
}

[data-theme="dark"] .header-actions .header-copy:hover,
[data-theme="dark"] .header-actions .header-copy:focus-visible {
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--copy-bg));
  border-color: var(--color-tab-active-bg);
  transform: translateY(-1px);
  box-shadow:
    0 8px 20px rgba(37, 99, 235, 0.35),
    0 0 40px rgba(37, 99, 235, 0.45);
  outline: none;
  color: var(--copy-ink);
}

/* === Chem header buttons: EXACT Ext2 glow === */
header .header-actions .header-copy{
  border: 1px solid var(--copy-border) !important;
  background: var(--copy-bg) !important;
  color: var(--copy-ink) !important;
  box-shadow: 0 6px 18px rgba(15,23,42,.25) !important;
  transition: background .18s ease, color .18s ease,
              box-shadow .18s ease, transform .12s ease,
              border-color .18s ease !important;
}

/* Hover/focus = Ext2 tint + lift (no neon ring) */
header .header-actions .header-copy:hover,
header .header-actions .header-copy:focus-visible{
  background: color-mix(in srgb, var(--color-tab-active-bg) 25%, var(--copy-bg)) !important;
  border-color: var(--color-tab-active-bg) !important;
  transform: translateY(-1px) !important;
  box-shadow: 0 12px 22px rgba(15,23,42,.18) !important; /* same depth as Ext2 keys */
  outline: none !important;     /* kill white/blue ring */
  filter: none !important;
}

/* Active press */
header .header-actions .header-copy:active{
  transform: translateY(0) !important;
  box-shadow: 0 2px 8px rgba(15,23,42,.25) !important;
}

/* Icons track text color */
header .header-actions .header-copy svg{ stroke: currentColor !important; }

</style>
<script>
  window.MathJax = {
    tex: { inlineMath: [['$', '$'], ['$$', '$$']], macros: { placeholder: '\\square' } },
    svg: { fontCache: 'global' }
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" defer></script>
<link rel="stylesheet" href="https://unpkg.com/mathlive/dist/mathlive.core.css">
<link rel="stylesheet" href="https://unpkg.com/mathlive/dist/mathlive.css">
</head>
<body>
<header>
  <div class="header-inner">
    <div class="header-left">
      <div class="header-actions">
        <button type="button" class="header-copy" id="headerCopyLatex">
          <i data-lucide="copy"></i> Copy LaTeX
        </button>
        <button type="button" class="header-copy" id="headerCopyWord">
          <i data-lucide="file-text"></i> Copy Word Equation
        </button>
      </div>
    </div>
    <div class="header-controls">
      <div class="theme-switch" role="group" aria-label="Theme">
        <button class="theme-opt" data-theme="light" title="Light" aria-label="Switch to light theme">
          <i data-lucide="sun"></i>
        </button>
        <button class="theme-opt" data-theme="dark" title="Dark" aria-label="Switch to dark theme">
          <i data-lucide="moon"></i>
        </button>
        <button class="theme-opt is-active" data-theme="system" title="System" aria-label="Use system theme">
          <i data-lucide="monitor"></i>
        </button>
      </div>
    </div>
  </div>
</header>
<main>
  <div class="panel">
    <div class="body" id="keyboard"></div>
  </div>

  <div class="card preview-card">
    <div class="body">
      <div id="preview"></div>
    </div>
  </div>

  <div class="card">
    <div class="body stack">
      <div class="editor">
        <label><strong>Rendered Input (Editable)</strong></label>
        <math-field id="mf" smart-fence letter-shape-style="tex" virtual-keyboard-mode="off" tabindex="0"></math-field>
      </div>
      <div class="editor">
        <label>
          <strong>Raw LaTeX Input</strong>
          <button id="copyLatex" class="copyBtn" type="button">Copy LaTeX</button>
        </label>
        <textarea id="ta"></textarea>
      </div>
      <div class="editor">
        <label>
          <strong>Word Equation</strong>
          <button id="copyWordBtn" class="copyBtn" type="button">Copy Word Equation</button>
        </label>
        <textarea id="wordOut" readonly></textarea>
      </div>
    </div>
  </div>
</main>

<script>
/* Theme toggle logic */
(function(){
  const html = document.documentElement;
  const opts = document.querySelectorAll('.theme-opt');
  const THEME_STORAGE_KEY = 'chem-typer-theme';
  const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');
  
  const apply = (mode)=>{
    opts.forEach(o=>o.classList.toggle('is-active', o.dataset.theme===mode));
    const resolved = mode === 'system' ? (prefersDarkScheme.matches ? 'dark' : 'light') : mode;
    html.setAttribute('data-theme', resolved); 
    html.style.colorScheme = resolved === 'dark' ? 'dark' : 'light';
    localStorage.setItem(THEME_STORAGE_KEY, mode); 
  };
  
  // Initialize - default to system
  const saved = localStorage.getItem(THEME_STORAGE_KEY) || 'system';
  apply(saved);
  
  // Bind click handlers
  opts.forEach(btn => btn.addEventListener('click', ()=> apply(btn.dataset.theme)));
  
  // Listen for system theme changes
  const handleSystemChange = () => {
    const current = localStorage.getItem(THEME_STORAGE_KEY) || 'system';
    if(current === 'system'){ apply('system'); }
  };
  if(typeof prefersDarkScheme.addEventListener === 'function'){
    prefersDarkScheme.addEventListener('change', handleSystemChange);
  } else if(typeof prefersDarkScheme.addListener === 'function'){
    prefersDarkScheme.addListener(handleSystemChange);
  }
})();

/* Initialize Lucide icons */
document.addEventListener('DOMContentLoaded', () => {
  lucide.createIcons();
});

const mathField = document.getElementById('mf');
const textArea = document.getElementById('ta');
const wordOutput = document.getElementById('wordOut');
const previewDiv = document.getElementById('preview');
const statusDiv = document.getElementById('status');

function showToast(message = 'Copied!') {
  const toast = document.getElementById('toast');
  if (!toast) return;
  toast.textContent = message;
  toast.classList.add('show');
  clearTimeout(showToast._timeout);
  showToast._timeout = setTimeout(() => toast.classList.remove('show'), 1600);
}

async function copyToClipboard(text, label = 'text') {
  let success = false;
  try {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      await navigator.clipboard.writeText(text);
      success = true;
    }
  } catch (err) {
    success = false;
  }

  if (!success) {
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.setAttribute('readonly', '');
    textarea.style.position = 'fixed';
    textarea.style.left = '-9999px';
    document.body.appendChild(textarea);
    textarea.select();
    try {
      success = document.execCommand('copy');
    } catch (err) {
      success = false;
    }
    document.body.removeChild(textarea);
  }

  if (statusDiv) {
    statusDiv.textContent = success ? `Copied ${label} âœ“` : `Copy ${label} failed`;
  }
  showToast(success ? `Copied ${label} âœ“` : 'Copy failed');
}

function typesetMath(){ 
  if(window.MathJax) {
    try {
      window.MathJax.typesetPromise([previewDiv]);
    } catch(e) {
      console.warn('MathJax typeset failed', e);
    }
  }
}

function toWordEquation(latex) {
    const supers = {
        '0': 'â°',
        '1': 'Â¹',
        '2': 'Â²',
        '3': 'Â³',
        '4': 'â´',
        '5': 'âµ',
        '6': 'â¶',
        '7': 'â·',
        '8': 'â¸',
        '9': 'â¹',
        '+': 'âº',
        '-': 'â»',
        '=': 'â¼',
        '(': 'â½',
        ')': 'â¾',
        'n': 'â¿',
        'i': 'â±'
    };
    const subs = {
        '0': 'â‚€',
        '1': 'â‚',
        '2': 'â‚‚',
        '3': 'â‚ƒ',
        '4': 'â‚„',
        '5': 'â‚…',
        '6': 'â‚†',
        '7': 'â‚‡',
        '8': 'â‚ˆ',
        '9': 'â‚‰',
        '+': 'â‚Š',
        '-': 'â‚‹',
        '=': 'â‚Œ',
        '(': 'â‚',
        ')': 'â‚Ž',
        'a': 'â‚',
        'e': 'â‚‘',
        'h': 'â‚•',
        'i': 'áµ¢',
        'j': 'â±¼',
        'k': 'â‚–',
        'l': 'â‚—',
        'm': 'â‚˜',
        'n': 'â‚™',
        'o': 'â‚’',
        'p': 'â‚š',
        'r': 'áµ£',
        's': 'â‚›',
        't': 'â‚œ',
        'u': 'áµ¤',
        'v': 'áµ¥',
        'x': 'â‚“'
    };
    const supersToAscii = {};
    for (const [plain, fancy] of Object.entries(supers)) {
        supersToAscii[fancy] = plain;
    }
    const subsToAscii = {};
    for (const [plain, fancy] of Object.entries(subs)) {
        subsToAscii[fancy] = plain;
    }
    const decodeSupers = (value = '') => Array.from(value).map((ch) => supersToAscii[ch] ?? ch).join('');
    const decodeSubs = (value = '') => Array.from(value).map((ch) => subsToAscii[ch] ?? ch).join('');
    const normalizeChemicalInput = (value = '') => {
        const stripped = String(value ?? '').replace(/[ã€–ã€—]/g, '').trim();
        if (!stripped) {
            return '';
        }
        let result = '';
        let pendingSub = '';
        let pendingSup = '';
        const flushDecorations = () => {
            if (pendingSub) {
                const subToken = /^[0-9]+$/.test(pendingSub) ? `_${pendingSub}` : `_{${pendingSub}}`;
                result += subToken;
                pendingSub = '';
            }
            if (pendingSup) {
                const supToken = /^[0-9+-]+$/.test(pendingSup) ? `^${pendingSup}` : `^{${pendingSup}}`;
                result += supToken;
                pendingSup = '';
            }
        };
        for (const ch of stripped) {
            if (Object.prototype.hasOwnProperty.call(subsToAscii, ch)) {
                pendingSub += subsToAscii[ch];
                continue;
            }
            if (Object.prototype.hasOwnProperty.call(supersToAscii, ch)) {
                pendingSup += supersToAscii[ch];
                continue;
            }
            flushDecorations();
            result += ch;
        }
        flushDecorations();
        return result;
    };
    const formatWordSymbol = (value = '') => {
        const raw = String(value ?? '').replace(/[ã€–ã€—]/g, '').trim();
        if (!raw) {
            return '';
        }
        let base = '';
        let sub = '';
        let sup = '';
        for (const ch of raw) {
            if (Object.prototype.hasOwnProperty.call(subsToAscii, ch)) {
                sub += subsToAscii[ch];
                continue;
            }
            if (Object.prototype.hasOwnProperty.call(supersToAscii, ch)) {
                sup += supersToAscii[ch];
                continue;
            }
            if ((ch === '+' || ch === '-') && sup) {
                sup += ch;
                continue;
            }
            base += ch;
        }
        let result = base;
        if (sub) {
            result += /^[0-9]+$/.test(sub) ? `_${sub}` : `_(${sub})`;
        }
        if (sup) {
            result += `^(${sup})`;
        }
        return result;
    };
    const formatChemicalFormula = (value = '') => {
        const raw = String(value ?? '').trim();
        if (!raw) {
            return '';
        }
        let i = 0;
        const len = raw.length;
        const tokens = [];
        let overallSup = '';
        const readGroup = () => {
            if (raw[i] === '{') {
                i++;
                let depth = 1;
                const startIndex = i;
                while (i < len && depth > 0) {
                    const ch = raw[i];
                    if (ch === '{') depth++;
                    else if (ch === '}') depth--;
                    i++;
                }
                return raw.slice(startIndex, i - 1).trim();
            }
            const startIndex = i;
            while (i < len && /[0-9+-]/.test(raw[i])) { i++; }
            return raw.slice(startIndex, i).trim();
        };

        while (i < len) {
            const ch = raw[i];
            if (ch === ' ') { i++; continue; }
            if (!/[A-Z]/.test(ch)) {
                return '';
            }
            let symbol = ch;
            i++;
            if (i < len && /[a-z]/.test(raw[i])) {
                symbol += raw[i];
                i++;
            }
            let sub = '';
            let sup = '';
            if (i < len && raw[i] === '_') {
                i++;
                sub = readGroup();
            }
            if (i < len && raw[i] === '^') {
                i++;
                sup = readGroup();
            }
            tokens.push({ symbol, sub, sup });
        }

        if (!tokens.length) {
            return '';
        }

        const supTokens = tokens.filter((t) => t.sup);
        if (supTokens.length === 1 && tokens.length > 1) {
            const last = tokens[tokens.length - 1];
            if (last.sup) {
                overallSup = last.sup;
                last.sup = '';
            }
        }

        const parts = tokens.map(({ symbol, sub, sup }) => {
            let part = symbol.length > 1 ? `ã€–${symbol}ã€—` : symbol;
            if (sub) {
                part += /^[0-9]+$/.test(sub) ? `_${sub}` : `_(${sub})`;
            }
            if (sup) {
                part += `^(${sup})`;
            }
            return part;
        });

        let inner = parts.join(' ');
        if (overallSup) {
            inner += `^(${overallSup})`;
        }
        return `ã€–${inner.trim()}ã€—`;
    };

    const greekMap = {
        alpha: 'Î±',
        beta: 'Î²',
        gamma: 'Î³',
        delta: 'Î´',
        Delta: 'Î”',
        epsilon: 'Îµ',
        varepsilon: 'Îµ',
        vartheta: 'Ï‘',
        theta: 'Î¸',
        Theta: 'Î˜',
        kappa: 'Îº',
        lambda: 'Î»',
        Lambda: 'Î›',
        mu: 'Î¼',
        nu: 'Î½',
        xi: 'Î¾',
        Xi: 'Îž',
        pi: 'Ï€',
        Pi: 'Î ',
        rho: 'Ï',
        sigma: 'Ïƒ',
        Sigma: 'Î£',
        tau: 'Ï„',
        upsilon: 'Ï…',
        Upsilon: 'Î¥',
        phi: 'Ï†',
        Phi: 'Î¦',
        varphi: 'Ï•',
        chi: 'Ï‡',
        psi: 'Ïˆ',
        Psi: 'Î¨',
        Gamma: 'Î“',
        Beta: 'Î’',
        Alpha: 'Î‘',
        Mu: 'Îœ',
        Rho: 'Î¡',
        Tau: 'Î¤',
        omega: 'Ï‰',
        Omega: 'Î©',
        zeta: 'Î¶',
        eta: 'Î·'
    };
    const doubleStruck = {
        'A': 'ð”¸', 'B': 'ð”¹', 'C': 'â„‚', 'D': 'ð”»', 'E': 'ð”¼', 'F': 'ð”½', 'G': 'ð”¾',
        'H': 'â„', 'I': 'ð•€', 'J': 'ð•', 'K': 'ð•‚', 'L': 'ð•ƒ', 'M': 'ð•„', 'N': 'â„•',
        'O': 'ð•†', 'P': 'â„™', 'Q': 'â„š', 'R': 'â„', 'S': 'ð•Š', 'T': 'ð•‹', 'U': 'ð•Œ',
        'V': 'ð•', 'W': 'ð•Ž', 'X': 'ð•', 'Y': 'ð•', 'Z': 'â„¤',
        'a': 'ð•’', 'b': 'ð•“', 'c': 'ð•”', 'd': 'ð••', 'e': 'ð•–', 'f': 'ð•—', 'g': 'ð•˜',
        'h': 'ð•™', 'i': 'ð•š', 'j': 'ð•›', 'k': 'ð•œ', 'l': 'ð•', 'm': 'ð•ž', 'n': 'ð•Ÿ',
        'o': 'ð• ', 'p': 'ð•¡', 'q': 'ð•¢', 'r': 'ð•£', 's': 'ð•¤', 't': 'ð•¥', 'u': 'ð•¦',
        'v': 'ð•§', 'w': 'ð•¨', 'x': 'ð•©', 'y': 'ð•ª', 'z': 'ð•«',
        '0': 'ðŸ˜', '1': 'ðŸ™', '2': 'ðŸš', '3': 'ðŸ›', '4': 'ðŸœ', '5': 'ðŸ',
        '6': 'ðŸž', '7': 'ðŸŸ', '8': 'ðŸ ', '9': 'ðŸ¡'
    };
    const scriptMap = {
        'A': 'ð’œ', 'B': 'â„¬', 'C': 'ð’ž', 'D': 'ð’Ÿ', 'E': 'â„°', 'F': 'â„±', 'G': 'ð’¢',
        'H': 'â„‹', 'I': 'â„', 'J': 'ð’¥', 'K': 'ð’¦', 'L': 'â„’', 'M': 'â„³', 'N': 'ð’©',
        'O': 'ð’ª', 'P': 'ð’«', 'Q': 'ð’¬', 'R': 'â„›', 'S': 'ð’®', 'T': 'ð’¯', 'U': 'ð’°',
        'V': 'ð’±', 'W': 'ð’²', 'X': 'ð’³', 'Y': 'ð’´', 'Z': 'ð’µ',
        'a': 'ð’¶', 'b': 'ð’·', 'c': 'ð’¸', 'd': 'ð’¹', 'e': 'â„¯', 'f': 'ð’»', 'g': 'â„Š',
        'h': 'ð’½', 'i': 'ð’¾', 'j': 'ð’¿', 'k': 'ð“€', 'l': 'ð“', 'm': 'ð“‚', 'n': 'ð“ƒ',
        'o': 'â„´', 'p': 'ð“…', 'q': 'ð“†', 'r': 'ð“‡', 's': 'ð“ˆ', 't': 'ð“‰', 'u': 'ð“Š',
        'v': 'ð“‹', 'w': 'ð“Œ', 'x': 'ð“', 'y': 'ð“Ž', 'z': 'ð“'
    };
    const frakturMap = {
        'A': 'ð”„', 'B': 'ð”…', 'C': 'â„­', 'D': 'ð”‡', 'E': 'ð”ˆ', 'F': 'ð”‰', 'G': 'ð”Š',
        'H': 'ð”‹', 'I': 'ð”Œ', 'J': 'ð”', 'K': 'ð”Ž', 'L': 'ð”', 'M': 'ð”', 'N': 'ð”‘',
        'O': 'ð”’', 'P': 'ð”“', 'Q': 'ð””', 'R': 'â„œ', 'S': 'ð”–', 'T': 'ð”—', 'U': 'ð”˜',
        'V': 'ð”™', 'W': 'ð”š', 'X': 'ð”›', 'Y': 'ð”œ', 'Z': 'â„¨',
        'a': 'ð”ž', 'b': 'ð”Ÿ', 'c': 'ð” ', 'd': 'ð”¡', 'e': 'ð”¢', 'f': 'ð”£', 'g': 'ð”¤',
        'h': 'ð”¥', 'i': 'ð”¦', 'j': 'ð”§', 'k': 'ð”¨', 'l': 'ð”©', 'm': 'ð”ª', 'n': 'ð”«',
        'o': 'ð”¬', 'p': 'ð”­', 'q': 'ð”®', 'r': 'ð”¯', 's': 'ð”°', 't': 'ð”±', 'u': 'ð”²',
        'v': 'ð”³', 'w': 'ð”´', 'x': 'ð”µ', 'y': 'ð”¶', 'z': 'ð”·'
    };
    const commandReplacements = [
        [/\\Longleftrightarrow/g, 'â‡”'],
        [/\\rightarrow\\rightleftharpoons/g, 'â‡Œ'],
        [/\\rightleftharpoons/g, 'â‡Œ'],
        [/\\leftharpoons/g, 'â‡Œ'],
        [/\\longleftrightarrow/g, 'âŸ·'],
        [/\\leftrightarrow/g, 'â†”'],
        [/\\Longrightarrow/g, 'â‡’'],
        [/\\Rightarrow/g, 'â‡’'],
        [/\\Longleftarrow/g, 'â‡'],
        [/\\Leftarrow/g, 'â‡'],
        [/\\longrightarrow/g, 'â†’'],
        [/\\rightarrow/g, 'â†’'],
        [/\\to\b/g, 'â†’'],
        [/\\longleftarrow/g, 'â†'],
        [/\\leftarrow/g, 'â†'],
        [/\\mapsto/g, 'â†¦'],
        [/\\implies/g, 'â‡’'],
        [/\\iff/g, 'â‡”'],
        [/\\uparrow/g, 'â†‘'],
        [/\\downarrow/g, 'â†“'],
        [/\\updownarrow/g, 'â†•'],
        [/\\rightleftharpoons/g, 'â‡Œ'],
        [/\\leftharpoondown/g, 'â†½'],
        [/\\rightharpoondown/g, 'â‡'],
        [/\\leftharpoonup/g, 'â†¼'],
        [/\\rightharpoonup/g, 'â‡€'],
        [/\\pm/g, 'Â±'],
        [/\\mp/g, 'âˆ“'],
        [/\\times/g, 'Ã—'],
        [/\\cdot/g, 'Â·'],
        [/\\div/g, 'Ã·'],
        [/\\ast/g, 'âˆ—'],
        [/\\star/g, 'â‹†'],
        [/\\bullet/g, 'â€¢'],
        [/\\circ/g, 'âˆ˜'],
        [/\\infty/g, 'âˆž'],
        [/\\partial/g, 'âˆ‚'],
        [/\\nabla/g, 'âˆ‡'],
        [/\\iiint/g, 'âˆ­'],
        [/\\iint/g, 'âˆ¬'],
        [/\\int/g, 'âˆ«'],
        [/\\sum/g, 'âˆ‘'],
        [/\\prod/g, 'âˆ'],
        [/\\oint/g, 'âˆ®'],
        [/\\therefore/g, 'âˆ´'],
        [/\\because/g, 'âˆµ'],
        [/\\angle/g, 'âˆ '],
        [/\\approx/g, 'â‰ˆ'],
        [/\\simeq/g, 'â‰ƒ'],
        [/\\sim/g, 'âˆ¼'],
        [/\\cong/g, 'â‰…'],
        [/\\neq/g, 'â‰ '],
        [/\\leqslant/g, 'â‰¤'],
        [/\\leq/g, 'â‰¤'],
        [/\\geqslant/g, 'â‰¥'],
        [/\\geq/g, 'â‰¥'],
        [/\\propto/g, 'âˆ'],
        [/\\subseteq/g, 'âŠ†'],
        [/\\supseteq/g, 'âŠ‡'],
        [/\\subset/g, 'âŠ‚'],
        [/\\supset/g, 'âŠƒ'],
        [/\\in/g, 'âˆˆ'],
        [/\\notin/g, 'âˆ‰'],
        [/\\ni/g, 'âˆ‹'],
        [/\\cup/g, 'âˆª'],
        [/\\cap/g, 'âˆ©'],
        [/\\setminus/g, 'âˆ–'],
        [/\\forall/g, 'âˆ€'],
        [/\\exists/g, 'âˆƒ'],
        [/\\land/g, 'âˆ§'],
        [/\\lor/g, 'âˆ¨'],
        [/\\neg/g, 'Â¬'],
        [/\\cdots/g, 'â‹¯'],
        [/\\ldots/g, 'â€¦'],
        [/\\dotsc/g, 'â€¦'],
        [/\\vdots/g, 'â‹®'],
        [/\\ddots/g, 'â‹±'],
        [/\\triangle/g, 'â–³'],
        [/\\bigtriangleup/g, 'â–³'],
        [/\\triangleleft/g, 'â—'],
        [/\\triangleright/g, 'â–·'],
        [/\\langle/g, 'âŸ¨'],
        [/\\rangle/g, 'âŸ©'],
        [/\\lfloor/g, 'âŒŠ'],
        [/\\rfloor/g, 'âŒ‹'],
        [/\\lceil/g, 'âŒˆ'],
        [/\\rceil/g, 'âŒ‰'],
        [/\\deg/g, 'Â°'],
        [/\\triangleq/g, 'â‰œ'],
        [/\\equiv/g, 'â‰¡'],
        [/\\perp/g, 'âŠ¥'],
        [/\\parallel/g, 'âˆ¥'],
        [/\\prime/g, 'â€²'],
        [/\\emptyset/g, 'âˆ…'],
        [/\\aleph/g, 'â„µ'],
        [/\\Box/g, 'â–¡']
    ];

    function mapToChars(value, table) {
        return Array.from(value).map((char) => table[char] || char).join('');
    }

    function simplifyFunctions(value) {
        return value.replace(/\\(sin|cos|tan|csc|sec|cot|log|ln|exp|max|min|mod)\b/g, (_, fn) => fn);
    }

    function cleanSegment(segment, depth = 0) {
        if (depth > 5) {
            return segment ?? '';
        }
        let text = String(segment ?? '');
        if (!text) {
            return '';
        }

        text = text.replace(/\r\n?/g, '\n');

        const wordArrow = (arrow, labelSource) => {
            const cleanLabel = cleanSegment(labelSource, depth + 1).trim();
            if (!cleanLabel) {
                return arrow;
            }
            return `â–¡(${arrow}â”´${cleanLabel} )`;
        };

        text = text.replace(/\\xrightarrow\s*\{\s*([^}]*)\s*\}/g, (_, label) => wordArrow('â†’', label));
        text = text.replace(/\\xleftarrow\s*\{\s*([^}]*)\s*\}/g, (_, label) => wordArrow('â†', label));
        text = text.replace(/\\xleftrightarrow\s*\{\s*([^}]*)\s*\}/g, (_, label) => wordArrow('â†”', label));

        text = text.replace(/\\frac\s*\{([^{}]+)\}\s*\{([^{}]+)\}/g, (_, num, den) => {
            const top = cleanSegment(num, depth + 1).trim();
            const bottom = cleanSegment(den, depth + 1).trim();
            if (!bottom) {
                return top;
            }
            return `${top}â„${bottom}`;
        });
        text = text.replace(/\\sqrt\s*\[\s*([^\]]+)\s*\]\s*\{([^{}]+)\}/g, (_, degree, radicand) => {
            const n = mapToChars(cleanSegment(degree, depth + 1).trim(), supers);
            const inside = cleanSegment(radicand, depth + 1);
            return `${n}âˆš(${inside})`;
        });
        text = text.replace(/\\sqrt\s*\{([^{}]+)\}/g, (_, radicand) => {
            const inside = cleanSegment(radicand, depth + 1);
            return `âˆš(${inside})`;
        });

        text = text.replace(/\\overline\s*\{([^{}]+)\}/g, (_, inner) => `${cleanSegment(inner, depth + 1)}Ì…`);
        text = text.replace(/\\bar\s*\{([^{}]+)\}/g, (_, inner) => `${cleanSegment(inner, depth + 1)}Ì„`);
        text = text.replace(/\\hat\s*\{([^{}]+)\}/g, (_, inner) => `${cleanSegment(inner, depth + 1)}Ì‚`);
        text = text.replace(/\\tilde\s*\{([^{}]+)\}/g, (_, inner) => `${cleanSegment(inner, depth + 1)}Ìƒ`);
        text = text.replace(/\\vec\s*\{([^{}]+)\}/g, (_, inner) => `${cleanSegment(inner, depth + 1)}âƒ—`);
        text = text.replace(/\\underline\s*\{([^{}]+)\}/g, (_, inner) => `${cleanSegment(inner, depth + 1)}Ì²`);

        text = text.replace(/\\rightarrow\\rightleftharpoons/g, 'â‡Œ');
        text = text.replace(/\\rightleftharpoons/g, 'â‡Œ');
        text = text.replace(/\\leftharpoons/g, 'â‡Œ');
        text = text.replace(/\\left(?=\s*[\(\[\{])/g, '');
        text = text.replace(/\\right(?=\s*[\)\]\}])/g, '');
        text = text.replace(/\\!/g, '');
        text = text.replace(/\\quad|\\qquad/g, '    ');
        text = text.replace(/\\,|\\;|\\:|\\thinspace/g, ' ');
        text = text.replace(/~/g, ' ');
        text = text.replace(/\\%/g, '%').replace(/\\#/g, '#').replace(/\\&/g, '&');
        text = text.replace(/\\\{/g, '{').replace(/\\\}/g, '}');
        text = text.replace(/\\_/g, '_');

        text = text.replace(/\\text\s*\{([^}]*)\}/g, (_, value) => cleanSegment(value, depth + 1));
        text = text.replace(/\\mathrm\s*\{([^}]*)\}/g, (_, value) => cleanSegment(value, depth + 1));
        text = text.replace(/\\operatorname\s*\{([^}]*)\}/g, (_, value) => cleanSegment(value, depth + 1));

        text = text.replace(/\\mathbb\s*\{([^{}]+)\}/g, (_, value) => mapToChars(cleanSegment(value, depth + 1), doubleStruck));
        text = text.replace(/\\mathcal\s*\{([^{}]+)\}/g, (_, value) => mapToChars(cleanSegment(value, depth + 1), scriptMap));
        text = text.replace(/\\mathscr\s*\{([^{}]+)\}/g, (_, value) => mapToChars(cleanSegment(value, depth + 1), scriptMap));
        text = text.replace(/\\mathfrak\s*\{([^{}]+)\}/g, (_, value) => mapToChars(cleanSegment(value, depth + 1), frakturMap));
        text = text.replace(/\\mathbf\s*\{([^{}]+)\}/g, (_, value) => cleanSegment(value, depth + 1));
        text = text.replace(/\\mathit\s*\{([^{}]+)\}/g, (_, value) => cleanSegment(value, depth + 1));
        text = text.replace(/\\mathsf\s*\{([^{}]+)\}/g, (_, value) => cleanSegment(value, depth + 1));
        text = text.replace(/\\mathnormal\s*\{([^{}]+)\}/g, (_, value) => cleanSegment(value, depth + 1));
        text = text.replace(/\{([^{}]+)\}(?=\s*_\(\((aq|s|l|g)\)\))/gi, '$1');
        text = text.replace(/_(?:\{\s*)?\((aq|s|l|g)\)(?:\s*\})?/gi, (_, state) => `_((` + state.toLowerCase() + `))`);
        text = text.replace(/([^\s]+)_\(\((aq|s|l|g)\)\)/gi, (full, species, state) => {
            if (species.startsWith('ã€–') && species.endsWith('ã€—')) {
                return `${species}_((` + state.toLowerCase() + `))`;
            }
            const cleaned = cleanSegment(species, depth + 1).trim();
            if (!cleaned) {
                return full;
            }
            const chemical = formatChemicalFormula(cleaned);
            if (chemical) {
                return `${chemical}_((` + state.toLowerCase() + `))`;
            }
            if (/(_\(|\^\(|ã€–)/.test(cleaned)) {
                return `ã€–${cleaned}ã€—_((` + state.toLowerCase() + `))`;
            }
            const formatted = formatWordSymbol(cleaned) || cleaned;
            return formatted ? `ã€–${formatted}ã€—_((` + state.toLowerCase() + `))` : full;
        });
        text = text.replace(/\\color\s*\{[^}]*\}/g, '');

        text = text.replace(/\\binom\s*\{([^{}]+)\}\s*\{([^{}]+)\}/g, (_, top, bottom) => `(${cleanSegment(top, depth + 1)} choose ${cleanSegment(bottom, depth + 1)})`);
        text = text.replace(/\\cfrac/g, '\\frac');
        text = text.replace(/\\choose/g, ' choose ');
        text = text.replace(/\\begin\s*\{[^}]*\}/g, '');
        text = text.replace(/\\end\s*\{[^}]*\}/g, '');
        text = text.replace(/&/g, ' ');

        text = text.replace(/\\\\/g, '\n');

        for (const [pattern, value] of commandReplacements) {
            text = text.replace(pattern, value);
        }

        text = text.replace(/â†’\s*â‡Œ/g, 'â‡Œ');

        text = simplifyFunctions(text);

        text = text.replace(/\\([A-Za-z]+)/g, (match, name) => {
            if (Object.prototype.hasOwnProperty.call(greekMap, name)) {
                return greekMap[name];
            }
            return name;
        });

        text = text.replace(/\\placeholder\{[^}]*\}/g, 'â–¡');

        // Superscripts: only convert when we have an explicit group or when
        // the caret is followed by a +, -, or a multi-digit/letter token common in chemistry charges (e.g., 2+, 3-, n+, etc.).
        // This avoids prematurely committing after typing a single digit like "2" before adding the sign.
        text = text.replace(/\^\{([^{}]+)\}/g, (_, content) => mapToChars(cleanSegment(content, depth + 1), supers));
        text = text.replace(/\^(\+|\-|[a-zA-Z]+[+\-]?|\d+[a-zA-Z]*[+\-]?)/g, (_, token) => mapToChars(token, supers));
        text = text.replace(/_(\{([^{}]+)\}|((?!\(\()[A-Za-z0-9+\-()=]))/g, (match, _whole, braced, single) => {
            const inner = braced ? braced : single;
            const plain = cleanSegment(inner, depth + 1);
            if (plain === '(' || plain === ')') {
                return match;
            }
            return mapToChars(plain, subs);
        });
        text = text.replace(/([â°Â¹Â²Â³â´âµâ¶â·â¸â¹âºâ»]+)\s*([â‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰â‚Šâ‚‹]+)\s*([A-Za-z][A-Za-z0-9]*)/g, (_, supPart, subPart, symbol) => `(_${decodeSubs(subPart)}^${decodeSupers(supPart)})${symbol}`);
        text = text.replace(/([â‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰â‚Šâ‚‹]+)\s*([â°Â¹Â²Â³â´âµâ¶â·â¸â¹âºâ»]+)\s*([A-Za-z][A-Za-z0-9]*)/g, (_, subPart, supPart, symbol) => `(_${decodeSubs(subPart)}^${decodeSupers(supPart)})${symbol}`);

        text = text.replace(/[{}]/g, '');
        text = text.replace(/\s+\n/g, '\n').replace(/\n\s+/g, '\n');
        text = text.replace(/[ \t]+/g, ' ');
        return text.trim();
    }

    return cleanSegment(latex);
}

function syncFromMath(){
  const val = mathField.getValue('latex') || '';
  textArea.value = val;
  wordOutput.value = toWordEquation(val);
  previewDiv.innerHTML = '$$' + val + '$$';
  typesetMath();
}

function syncFromText(){
  const val = textArea.value;
  wordOutput.value = toWordEquation(val);
  previewDiv.innerHTML = '$$' + val + '$$';
  typesetMath();
  mathField.setValue(val);
}

// Fixed regex to match the actual state format: _{(state)}
const stateRegex = /_\{\((?:s|l|g|aq)\)\}$/;

function setupMathField(){
  mathField.setOptions({virtualKeyboardMode:'off',inlineShortcuts:{},overrideDefaultInlineShortcuts:true});
  mathField.addEventListener('input', syncFromMath);
  textArea.addEventListener('input', syncFromText);

  mathField.addEventListener('keydown', (e)=>{
    // Do not hijack normal typing after arrows; only handle space-to-\\: mapping
    // when not immediately after a control sequence or arrow.
    if(e.key === ' '){
      const val = mathField.getValue('latex') || '';
      // If we're in the middle of a control sequence like \\rightarrow or just typed \\xrightarrow{...},
      // allow a normal space so typing doesn't freeze.
      if(/\\\\[A-Za-z]+$/.test(val) || /\\\\x(?:left|right)arrow\s*\{[^}]*\}$/.test(val)){
        return; // let space pass through
      }
      e.preventDefault();
      insertText(' \\: ');
      return;
    }
    if(e.key !== 'Backspace') return;
    const latex = mathField.getValue('latex') || '';
    if(stateRegex.test(latex)){
      e.preventDefault();
      mathField.setValue(latex.replace(stateRegex, ''));
      syncFromMath();
    }
  });

  textArea.addEventListener('keydown', (e)=>{
    if(e.key !== 'Backspace') return;
    const v = textArea.value || '';
    if(stateRegex.test(v)){
      e.preventDefault();
      const result = v.replace(stateRegex, '');
      textArea.value = result;
      textArea.setSelectionRange(result.length, result.length);
      syncFromText();
    }
  });

  mathField.focus();
  syncFromMath();
}

// Fixed regex to match the actual state format
function stripState(text){
  const match = text.match(/^(.*)_\{\((?:s|l|g|aq)\)\}$/);
  return match ? match[1] : text;
}

function findSpeciesStart(latex, position){
  let i = position - 1;
  while(i >= 0 && /\s/.test(latex[i])) i--;
  let start = i + 1;
  const isBoundary = (ch, prev) => {
    if(!ch) return true;
    if(/[\s+=><]/.test(ch)) return true; // minus is special-cased below
    if(ch === 'Â·' || ch === '\\') return true;
    if(ch === '-' && prev !== '^') return true;
    return false;
  };
  function scanBalanced(close, open){
    let depth = 0, k = i;
    for(; k >= 0; k--){
      const c = latex[k];
      if(c === close) depth++;
      else if(c === open){
        depth--;
        if(depth === 0) break;
      }
    }
    return k;
  }
  while(i >= 0){
    const c = latex[i], prev = latex[i-1];
    if(c === '}'){
      const k = scanBalanced('}', '{');
      if(k < 0) break;
      start = k; i = k - 1;
      if(latex[i] === '^' || latex[i] === '_'){ start = i; i--; continue; }
      continue;
    }
    if(c === ')'){
      const k = scanBalanced(')', '(');
      if(k < 0) break;
      start = k; i = k - 1; continue;
    }
    if(/[a-z]/.test(c)){
      let k = i; while(k >= 0 && /[a-z]/.test(latex[k])) k--;
      if(k >= 0 && /[A-Z]/.test(latex[k])){ start = k; i = k - 1; continue; }
      start = k + 1; i = k; continue;
    }
    if(/[A-Z]/.test(c)){ start = i; i--; continue; }
    if(/[0-9]/.test(c)){
      let k = i; while(k >= 0 && /[0-9]/.test(latex[k])) k--;
      const before = latex[k];
      if(before && /[a-zA-Z)}]/.test(before)){ start = k + 1; i = k; continue; }
      break;
    }
    if(isBoundary(c, prev)) break;
    start = i; i--;
  }
  return Math.max(0, start);
}

function applyStateToText(latex, position, state){
  const left = stripState(latex.slice(0, position));
  const right = latex.slice(position);
  const base = left + right;
  const newPos = left.length;
  const start = findSpeciesStart(base, newPos);
  const species = base.slice(start, newPos);
  const result = base.slice(0, start) + '{' + species + '}_{(' + state + ')}' + base.slice(newPos);
  return { result, position: (base.slice(0, start) + '{' + species + '}_{(' + state + ')}').length };
}

function applyState(state){
  let latex = mathField.getValue('latex') || '';
  const position = latex.length;
  const { result } = applyStateToText(latex, position, state);
  mathField.setValue(result);
  syncFromMath();
}

function insertText(text){ mathField.insert(text); syncFromMath(); }

const chemKeys = [
  { display: '\\rightarrow', insert: ' \\rightarrow ' },
  { display: '\\rightleftharpoons', insert: ' \\rightleftharpoons ' },
  { display: '\\xrightarrow{\\placeholder{}}', insert: ' \\xrightarrow{\\placeholder{}} ' },
  { display: '(s)', action: () => applyState('s') },
  { display: '(l)', action: () => applyState('l') },
  { display: '(g)', action: () => applyState('g') },
  { display: '(aq)', action: () => applyState('aq') },
  { display: '\\xrightarrow{\\Delta}', insert: ' \\xrightarrow{\\Delta} ' },
  { display: '^{\\placeholder{}}_{\\placeholder{}}\\placeholder{}', insert: '^{\\placeholder{}}_{\\placeholder{}}\\placeholder{}' },
  { display: '\\alpha', insert: '\\alpha' },
  { display: '\\beta', insert: '\\beta' },
  { display: '\\gamma', insert: '\\gamma' },
  { display: '\\overline{\\beta}\\:', insert: '\\overline{\\beta}\\:' }
];

function buildKeys(){
  const container = document.getElementById('keyboard');
  container.innerHTML = '';
  chemKeys.forEach(key => {
    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'key';
    button.innerHTML = '$$' + key.display + '$$';
    button.addEventListener('click', () => { if(key.action) key.action(); else insertText(key.insert); });
    container.appendChild(button);
  });
  if(window.MathJax) window.MathJax.typesetPromise([container]);
}

(async()=>{
  const urls = ['https://cdn.jsdelivr.net/npm/mathlive/dist/mathlive.min.js','https://unpkg.com/mathlive/dist/mathlive.min.js'];
  let mathLiveLoaded = false;
  
  for(const url of urls){
    try{
      await new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = url; 
        script.defer = true; 
        script.onload = () => {
          mathLiveLoaded = true;
          resolve();
        }; 
        script.onerror = reject;
        document.head.appendChild(script);
      });
      break;
    }catch(e){
      console.warn('Failed to load MathLive from', url, e);
    }
  }
  
  // Wait for MathLive to be defined
  if(window.customElements && window.customElements.whenDefined) {
    try {
      await customElements.whenDefined('math-field');
    } catch(e) {
      console.warn('MathLive custom element not defined', e);
    }
  }
  
  // Setup regardless of MathLive status
  setupMathField();
  buildKeys();
})();

document.getElementById('copyLatex').addEventListener('click', () => {
  copyToClipboard(textArea.value, 'LaTeX');
});

document.getElementById('copyWordBtn').addEventListener('click', () => {
  copyToClipboard(wordOutput.value, 'word equation');
});

document.getElementById('headerCopyLatex').addEventListener('click', () => {
  copyToClipboard(textArea.value, 'LaTeX');
});

document.getElementById('headerCopyWord').addEventListener('click', () => {
  copyToClipboard(wordOutput.value, 'word equation');
});
</script>

<div id="toast" role="status" aria-live="polite"></div>
</body>
</html>
