<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
<meta charset="utf-8" />
<title>HSC Chemistry – Equation Typer (with Isotopes)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
:root {
  color-scheme: light;
  --color-bg: #f8fafc;
  --color-surface: #ffffff;
  --color-surface-alt: #e2e8f0;
  --color-ink: #0f172a;
  --color-muted: #64748b;
  --color-border: #d1d5db;
  --color-border-strong: #cbd5e1;
  --color-brand: #2563eb;
  --color-header-text: #ffffff;
  --color-button-bg: #ffffff;
}

[data-theme="dark"] {
  color-scheme: dark;
  --color-bg: #0f172a;
  --color-surface: #111827;
  --color-surface-alt: #1f2937;
  --color-ink: #e2e8f0;
  --color-muted: #94a3b8;
  --color-border: #334155;
  --color-border-strong: #1f2937;
  --color-brand: #2563eb;
  --color-header-text: #e2e8f0;
  --color-button-bg: #1e293b;
}

*{box-sizing:border-box}
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial,'Noto Sans',sans-serif;margin:0;background:var(--color-bg);color:var(--color-ink);transition:background-color .2s ease,color .2s ease;}
header{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:12px 16px;background:var(--color-brand);color:var(--color-header-text);}
header h1{font-size:18px;margin:0;}
.header-controls{display:flex;align-items:center;gap:12px;font-size:12px;}
#status{font-size:12px;}
.theme-switcher{display:flex;align-items:center;gap:6px;}
.theme-switcher span{font-weight:600;}
.theme-switcher select{padding:2px 6px;font-size:12px;border-radius:6px;border:1px solid var(--color-border);background:var(--color-button-bg);color:var(--color-ink);}
main{max-width:980px;margin:18px auto;padding:0 12px 24px;}
.panel{background:var(--color-surface);border:1px solid var(--color-border);border-radius:12px;overflow:hidden;margin-bottom:12px;box-shadow:0 1px 2px rgba(15,23,42,0.04);}
.panel .head{padding:10px 12px;border-bottom:1px solid var(--color-border-strong);font-weight:600;}
.panel .body{padding:12px;}
math-field, textarea{width:100%;min-height:56px;font-size:18px;padding:8px 10px;border:1px solid var(--color-border);border-radius:10px;background:var(--color-surface-alt);color:var(--color-ink);transition:background-color .2s ease,color .2s ease,border-color .2s ease;}
textarea[readonly]{background:var(--color-surface-alt);}
math-field::part(content){color:var(--color-ink);}
math-field::part(caret){border-left:2px solid var(--color-brand);}
#preview{min-height:56px;padding:8px 10px;border:1px solid var(--color-border);border-radius:10px;background:var(--color-surface-alt);color:var(--color-ink);}
.row{display:grid;grid-template-columns:1fr auto;gap:10px;align-items:center;}
button{font-family:inherit;}
.btn{padding:6px 10px;border:1px solid var(--color-border);border-radius:8px;background:var(--color-button-bg);color:var(--color-ink);cursor:pointer;transition:background-color .2s ease,color .2s ease,border-color .2s ease;}
.btn:active{transform:translateY(1px);}
.btn:focus-visible,.theme-switcher select:focus-visible{outline:2px solid var(--color-brand);outline-offset:2px;}
#keyboard{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:8px;}
.key{display:flex;align-items:center;justify-content:center;min-height:56px;padding:8px;background:var(--color-surface-alt);border:1px solid var(--color-border);border-radius:12px;cursor:pointer;color:var(--color-ink);transition:background-color .2s ease,color .2s ease,border-color .2s ease;}
.key mjx-container{font-size:24px;max-width:100%;}
.hint{font-size:12px;color:var(--color-muted);margin:0;padding:0 12px 12px;}
math-field::part(virtual-keyboard-toggle), math-field::part(menu-toggle), math-field::part(toolbar){display:none!important;}
@media (max-width:600px){.row{grid-template-columns:1fr;}.btn{width:100%;}}
</style>
<script>
  window.MathJax = {
    tex: { inlineMath: [['$', '$'], ['$$', '$$']], macros: { placeholder: '\\square' } },
    svg: { fontCache: 'global' }
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" defer></script>
<link rel="stylesheet" href="https://unpkg.com/mathlive/dist/mathlive.core.css">
<link rel="stylesheet" href="https://unpkg.com/mathlive/dist/mathlive.css">
</head>
<body>
<header>
  <h1>HSC Chemistry – Equation Typer</h1>
  <div class="header-controls">
    <div id="status">Loading…</div>
    <label class="theme-switcher">
      <span>Theme</span>
      <select id="themeMode" aria-label="Theme selection">
        <option value="system">System</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
      </select>
    </label>
  </div>
</header>
<main>
  <div class="panel">
    <div class="head">Preview</div>
    <div class="body">
      <div id="preview"></div>
    </div>
  </div>

  <div class="panel">
    <div class="head">Rendered Input</div>
    <div class="body">
      <math-field id="mf" smart-fence letter-shape-style="tex" virtual-keyboard-mode="off" tabindex="0" placeholder="Type here…"></math-field>
    </div>
  </div>

  <div class="panel">
    <div class="head">Raw LaTeX</div>
    <div class="body">
      <div class="row">
        <textarea id="ta" placeholder="Type or paste LaTeX here…"></textarea>
        <button id="copyLatex" class="btn">Copy LaTeX</button>
      </div>
    </div>
  </div>

  <div class="panel">
    <div class="head">Word Equation</div>
    <div class="body">
      <div class="row">
        <textarea id="wordOut" placeholder="Word equation output…" readonly></textarea>
        <button id="copyWordBtn" class="btn">Copy Word Equation</button>
      </div>
    </div>
  </div>

  <div class="panel">
    <div class="head">Chemistry Keys</div>
    <div class="body" id="keyboard"></div>
    <p class="hint">State buttons auto-wrap the entire species (with charge and nested groups, skipping coefficients) into braces, then add the state outside: e.g. <code>Fe2(SO4)3^{2-}</code> + (aq) → <code>{Fe2(SO4)3^{2-}}_{(aq)}</code>. Backspace removes a whole state in one press. Spacebar types a thin space (LaTeX <code>\:</code>).</p>
  </div>
</main>

<script>
const mathField = document.getElementById('mf');
const textArea = document.getElementById('ta');
const wordOutput = document.getElementById('wordOut');
const previewDiv = document.getElementById('preview');
const statusDiv = document.getElementById('status');
const themeSelect = document.getElementById('themeMode');

const THEME_STORAGE_KEY = 'theme-preference';
const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');
const themeStorage = {
  get(){ try { return localStorage.getItem(THEME_STORAGE_KEY); } catch { return null; } },
  set(value){ try { localStorage.setItem(THEME_STORAGE_KEY, value); } catch {} }
};

const resolveTheme = (choice) => choice === 'system' ? (prefersDarkScheme.matches ? 'dark' : 'light') : choice;
function setDocumentTheme(theme){
  document.documentElement.setAttribute('data-theme', theme);
  document.documentElement.style.colorScheme = theme === 'dark' ? 'dark' : 'light';
}
function applyTheme(choice){
  const resolved = resolveTheme(choice);
  setDocumentTheme(resolved);
  if(themeSelect && themeSelect.value !== choice){
    themeSelect.value = choice;
  }
}

applyTheme(themeStorage.get() || 'system');
if(themeSelect){
  themeSelect.addEventListener('change', (event) => {
    const selection = event.target.value;
    applyTheme(selection);
    themeStorage.set(selection);
  });
}
const handleSystemThemeChange = () => {
  const current = themeStorage.get() || 'system';
  if(current === 'system'){
    applyTheme('system');
  }
};
if(typeof prefersDarkScheme.addEventListener === 'function'){
  prefersDarkScheme.addEventListener('change', handleSystemThemeChange);
} else if(typeof prefersDarkScheme.addListener === 'function'){
  prefersDarkScheme.addListener(handleSystemThemeChange);
}

function typesetMath(){ if(window.MathJax) window.MathJax.typesetPromise([previewDiv]); }

function toWordEquation(latex) {
  let w = latex;

  // 1) Arrows
  w = w.replace(/\xrightarrow\{([^}]*)\}/g, '\buildrel $1 \over \longlongrightarrow');

  // 2) Thin space to real space
  w = w.replace(/\:/g, ' ');

  // 3) Isotope conversion ONLY
  // Base X allowed: element symbol [A-Z][a-z]?, or {…}, or \placeholder{…}
  const EL = '(?:[A-Z][a-z]?|\\{[^}]*\\}|\\\\placeholder\\{[^}]*\\})';

    // a) ^{A}_{Z}X OR ^{A}_Z X  →  {_{ {Z} }^{ {A} }}X
    w = w.replace(
    new RegExp('\\^\\{\\s*([^}]*)\\s*\\}_(?:\\{\\s*([^}]*)\\s*\\}|\\s*([^\\s]+))\\s*(' + EL + ')', 'g'),
    (m, A, Z1, Z2, X) => `{_{ {${Z1 || Z2}} }^{ {${A}} }}${X}`
    );

    // b) _{Z}^{A}X OR _Z^{A}X  →  {_{ {Z} }^{ {A} }}X
    w = w.replace(
    new RegExp('_(?:\\{\\s*([^}]*)\\s*\\}|\\s*([^\\s]+))\\s*\\^\\{\\s*([^}]*)\\s*\\}\\s*(' + EL + ')', 'g'),
    (m, Z1, Z2, A, X) => `{_{ {${Z1 || Z2}} }^{ {${A}} }}${X}`
    );



  // 4) Greek shortcuts → Unicode
  w = w.replace(/\\alpha/g, 'α');
  w = w.replace(/\\beta/g, 'β');
  w = w.replace(/\\gamma/g, 'γ');

  // 5) Placeholders marker
  w = w.replace(/\\placeholder\{[^}]*\}/g, '[placeholder]');

  return w;
}

function syncFromMath(){
  const val = mathField.getValue('latex') || '';
  textArea.value = val;
  wordOutput.value = toWordEquation(val);
  previewDiv.innerHTML = '$$' + val + '$$';
  typesetMath();
}

function syncFromText(){
  const val = textArea.value;
  wordOutput.value = toWordEquation(val);
  previewDiv.innerHTML = '$$' + val + '$$';
  typesetMath();
  mathField.setValue(val);
}

// Fixed regex to match the actual state format: _{(state)}
const stateRegex = /_\{\((?:s|l|g|aq)\)\}$/;

function setupMathField(){
  mathField.setOptions({virtualKeyboardMode:'off',inlineShortcuts:{},overrideDefaultInlineShortcuts:true});
  mathField.addEventListener('input', syncFromMath);
  textArea.addEventListener('input', syncFromText);

  mathField.addEventListener('keydown', (e)=>{
    if(e.key === ' '){ e.preventDefault(); insertText(' \\: '); return; }
    if(e.key !== 'Backspace') return;
    const latex = mathField.getValue('latex') || '';
    if(stateRegex.test(latex)){
      e.preventDefault();
      mathField.setValue(latex.replace(stateRegex, ''));
      syncFromMath();
    }
  });

  textArea.addEventListener('keydown', (e)=>{
    if(e.key !== 'Backspace') return;
    const v = textArea.value || '';
    if(stateRegex.test(v)){
      e.preventDefault();
      const result = v.replace(stateRegex, '');
      textArea.value = result;
      textArea.setSelectionRange(result.length, result.length);
      syncFromText();
    }
  });

  mathField.focus();
  syncFromMath();
}

// Fixed regex to match the actual state format
function stripState(text){
  const match = text.match(/^(.*)_\{\((?:s|l|g|aq)\)\}$/);
  return match ? match[1] : text;
}

function findSpeciesStart(latex, position){
  let i = position - 1;
  while(i >= 0 && /\s/.test(latex[i])) i--;
  let start = i + 1;
  const isBoundary = (ch, prev) => {
    if(!ch) return true;
    if(/[\s+=><]/.test(ch)) return true; // minus is special-cased below
    if(ch === '·' || ch === '\\') return true;
    if(ch === '-' && prev !== '^') return true;
    return false;
  };
  function scanBalanced(close, open){
    let depth = 0, k = i;
    for(; k >= 0; k--){
      const c = latex[k];
      if(c === close) depth++;
      else if(c === open){
        depth--;
        if(depth === 0) break;
      }
    }
    return k;
  }
  while(i >= 0){
    const c = latex[i], prev = latex[i-1];
    if(c === '}'){
      const k = scanBalanced('}', '{');
      if(k < 0) break;
      start = k; i = k - 1;
      if(latex[i] === '^' || latex[i] === '_'){ start = i; i--; continue; }
      continue;
    }
    if(c === ')'){
      const k = scanBalanced(')', '(');
      if(k < 0) break;
      start = k; i = k - 1; continue;
    }
    if(/[a-z]/.test(c)){
      let k = i; while(k >= 0 && /[a-z]/.test(latex[k])) k--;
      if(k >= 0 && /[A-Z]/.test(latex[k])){ start = k; i = k - 1; continue; }
      start = k + 1; i = k; continue;
    }
    if(/[A-Z]/.test(c)){ start = i; i--; continue; }
    if(/[0-9]/.test(c)){
      let k = i; while(k >= 0 && /[0-9]/.test(latex[k])) k--;
      const before = latex[k];
      if(before && /[a-zA-Z)}]/.test(before)){ start = k + 1; i = k; continue; }
      break;
    }
    if(isBoundary(c, prev)) break;
    start = i; i--;
  }
  return Math.max(0, start);
}

function applyStateToText(latex, position, state){
  const left = stripState(latex.slice(0, position));
  const right = latex.slice(position);
  const base = left + right;
  const newPos = left.length;
  const start = findSpeciesStart(base, newPos);
  const species = base.slice(start, newPos);
  const result = base.slice(0, start) + '{' + species + '}_{(' + state + ')}' + base.slice(newPos);
  return { result, position: (base.slice(0, start) + '{' + species + '}_{(' + state + ')}').length };
}

function applyState(state){
  let latex = mathField.getValue('latex') || '';
  const position = latex.length;
  const { result } = applyStateToText(latex, position, state);
  mathField.setValue(result);
  syncFromMath();
}

function insertText(text){ mathField.insert(text); syncFromMath(); }

const chemKeys = [
  { display: '\\rightarrow', insert: ' \\rightarrow ' },
  { display: '\\rightleftharpoons', insert: ' \\rightleftharpoons ' },
  { display: '\\xrightarrow{\\Delta}', insert: ' \\xrightarrow{\\Delta} ' },
  { display: '\\xrightarrow{\\placeholder{}}', insert: ' \\xrightarrow{\\placeholder{}} ' },
  { display: '^{\\placeholder{}}_{\\placeholder{}}\\placeholder{}', insert: '^{\\placeholder{}}_{\\placeholder{}}\\placeholder{}' },
  { display: '\\alpha', insert: '\\alpha' },
  { display: '\\beta', insert: '\\beta' },
  { display: '\\gamma', insert: '\\gamma' },
  { display: '(s)', action: () => applyState('s') },
  { display: '(l)', action: () => applyState('l') },
  { display: '(g)', action: () => applyState('g') },
  { display: '(aq)', action: () => applyState('aq') }
];

function buildKeys(){
  const container = document.getElementById('keyboard');
  container.innerHTML = '';
  chemKeys.forEach(key => {
    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'key';
    button.innerHTML = '$$' + key.display + '$$';
    button.addEventListener('click', () => { if(key.action) key.action(); else insertText(key.insert); });
    container.appendChild(button);
  });
  if(window.MathJax) window.MathJax.typesetPromise([container]);
}

(async()=>{
  const urls = ['https://cdn.jsdelivr.net/npm/mathlive/dist/mathlive.min.js','https://unpkg.com/mathlive/dist/mathlive.min.js'];
  for(const url of urls){
    try{
      await new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = url; script.defer = true; script.onload = resolve; script.onerror = reject;
        document.head.appendChild(script);
      });
      break;
    }catch(e){}
  }
  if(window.customElements && window.customElements.whenDefined) await customElements.whenDefined('math-field');
  setupMathField();
  buildKeys();
  statusDiv.textContent = 'Ready';
})();

document.getElementById('copyLatex').onclick = async () => {
  try {
    await navigator.clipboard.writeText(textArea.value);
  } catch (e) {
    console.error('Failed to copy LaTeX:', e);
  }
};

document.getElementById('copyWordBtn').onclick = async () => {
  try {
    await navigator.clipboard.writeText(wordOutput.value);
  } catch (e) {
    console.error('Failed to copy Word Equation:', e);
  }
};
</script>
</body>
</html>